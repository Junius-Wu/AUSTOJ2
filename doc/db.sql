# ************************************************************
# Sequel Pro SQL dump
# Version 4541
#
# http://www.sequelpro.com/
# https://github.com/sequelpro/sequelpro
#
# Host: 127.0.0.1 (MySQL 5.7.17)
# Database: aust
# Generation Time: 2017-03-25 05:00:07 +0000
# ************************************************************


/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;


# Dump of table article
# ------------------------------------------------------------

DROP TABLE IF EXISTS `article`;

CREATE TABLE `article` (
  `id` bigint(11) NOT NULL COMMENT '主键',
  `title` varchar(255) DEFAULT NULL COMMENT '标题',
  `user_id` int(11) DEFAULT NULL COMMENT '用户id',
  `summary` text COMMENT '摘要',
  `html_content` text COMMENT 'html类型',
  `content` text COMMENT 'markdown类型',
  `keyword` varchar(255) DEFAULT NULL COMMENT '关键词,都好分隔',
  `viewcount` int(11) DEFAULT '0' COMMENT '阅读数',
  `likecount` int(11) DEFAULT '0' COMMENT '点赞数',
  `catelog_id` int(5) DEFAULT NULL COMMENT '暂且废除字段',
  `is_top` tinyint(4) DEFAULT '0' COMMENT '0不置顶,1置顶',
  `is_show` tinyint(4) DEFAULT '1' COMMENT '0不展示,1展示',
  `createdate` datetime DEFAULT NULL,
  `modifydate` datetime DEFAULT NULL,
  `source` tinyint(4) DEFAULT '1' COMMENT '文章来源1站内2csdn',
  `source_link` varchar(255) DEFAULT NULL COMMENT '原文链接',
  `source_author` varchar(255) DEFAULT NULL COMMENT '原文作者链接',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

LOCK TABLES `article` WRITE;
/*!40000 ALTER TABLE `article` DISABLE KEYS */;

INSERT INTO `article` (`id`, `title`, `user_id`, `summary`, `html_content`, `content`, `keyword`, `viewcount`, `likecount`, `catelog_id`, `is_top`, `is_show`, `createdate`, `modifydate`, `source`, `source_link`, `source_author`)
VALUES
	(1,'SpringMVC学习记录(一)--环境配置',1,'在IDEA下配置SpringMVC环境是相当简单的,这里强烈推荐Intellij IDEA开发javaWEB简直完爆eclipse.1.创建项目创建项目很简单,直接选择SpringMVC即可,并且IDEA会自动配置Spring的架包 创建后的项目结构如下: 2.基本配置和tomcat服务器配置首先在WEB-INF文件夹中建立lib文件夹,用于放我们自己的包,然后在Project Structur...','<p>在IDEA下配置SpringMVC环境是相当简单的,这里强烈推荐Intellij IDEA开发javaWEB简直完爆eclipse.</p>\r\n\r\n<hr>\r\n\r\n<h2 id=\"title\">1.创建项目</h2>\r\n\r\n<p>创建项目很简单,直接选择SpringMVC即可,并且IDEA会自动配置Spring的架包 <br>\r\n<img src=\"http://img.blog.csdn.net/20160404134234985\" alt=\"这里写图片描述\" title=\"\"></p>\r\n\r\n<p>创建后的项目结构如下: <br>\r\n<img src=\"http://img.blog.csdn.net/20160404134818300\" alt=\"这里写图片描述\" title=\"\"></p>\r\n\r\n<hr>\r\n\r\n<h2 id=\"title-1\">2.基本配置和tomcat服务器配置</h2>\r\n\r\n<p>首先在WEB-INF文件夹中建立lib文件夹,用于放我们自己的包,然后在Project Structure里面加入我们的包和tomcat的包 <br>\r\n<img src=\"http://img.blog.csdn.net/20160404142948737\" alt=\"这里写图片描述\" title=\"\"></p>\r\n\r\n<p>然后在运行那里配置tomcat服务器 <br>\r\n<img src=\"http://img.blog.csdn.net/20160404143224395\" alt=\"这里写图片描述\" title=\"\"></p>\r\n\r\n<p>到此环境算配置完毕,其他很多工作IDEA都帮我们做好了,下面分析下IDEA做的那些配置</p>\r\n\r\n<hr>\r\n\r\n<h2 id=\"title-2\">3.各种xml文件配置</h2>\r\n\r\n<ul>\r\n<li>web.xml</li>\r\n</ul>\r\n\r\n<pre class=\"prettyprint hljs-dark\"><code class=\" hljs xml\"><span class=\"hljs-pi\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span>\r\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">web-app</span> <span class=\"hljs-attribute\">xmlns</span>=<span class=\"hljs-value\">\"http://xmlns.jcp.org/xml/ns/javaee\"</span>\r\n         <span class=\"hljs-attribute\">xmlns:xsi</span>=<span class=\"hljs-value\">\"http://www.w3.org/2001/XMLSchema-instance\"</span>\r\n         <span class=\"hljs-attribute\">xsi:schemaLocation</span>=<span class=\"hljs-value\">\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd\"</span>\r\n         <span class=\"hljs-attribute\">version</span>=<span class=\"hljs-value\">\"3.1\"</span>&gt;</span>\r\n    <span class=\"hljs-comment\">&lt;!--指定spring的配置文件所在的目录--&gt;</span>\r\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">context-param</span>&gt;</span>\r\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">param-name</span>&gt;</span>contextConfigLocation<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">param-name</span>&gt;</span>\r\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">param-value</span>&gt;</span>/WEB-INF/applicationContext.xml<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">param-value</span>&gt;</span>\r\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">context-param</span>&gt;</span>\r\n    <span class=\"hljs-comment\">&lt;!--设置spring监听器--&gt;</span>\r\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">listener</span>&gt;</span>\r\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">listener-class</span>&gt;</span>\r\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">listener</span>&gt;</span>\r\n    <span class=\"hljs-comment\">&lt;!--配置springMVC,这里的servlet名称决定着SpringMVC配置文件的名称--&gt;</span>\r\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">servlet</span>&gt;</span>\r\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">servlet-name</span>&gt;</span>dispatcher<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">servlet-name</span>&gt;</span>\r\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">servlet-class</span>&gt;</span>\r\n        <span class=\"hljs-comment\">&lt;!--启动时加载,1代表优先级,越小代表越高--&gt;</span>\r\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">load-on-startup</span>&gt;</span>1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">load-on-startup</span>&gt;</span>\r\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">servlet</span>&gt;</span>\r\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">servlet-mapping</span>&gt;</span>\r\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">servlet-name</span>&gt;</span>dispatcher<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">servlet-name</span>&gt;</span>\r\n        <span class=\"hljs-comment\">&lt;!--这里修改为全部页面--&gt;</span>\r\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">url-pattern</span>&gt;</span>/<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">url-pattern</span>&gt;</span>\r\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">servlet-mapping</span>&gt;</span>\r\n\r\n<span class=\"hljs-comment\">&lt;!--配置请求编码(这一部分是手动配置的)--&gt;</span>\r\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">filter</span>&gt;</span>\r\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">filter-name</span>&gt;</span>encodingFilter<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">filter-name</span>&gt;</span>\r\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">filter-class</span>&gt;</span>\r\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">init-param</span>&gt;</span>\r\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">param-name</span>&gt;</span>encoding<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">param-name</span>&gt;</span>\r\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">param-value</span>&gt;</span>UTF-8<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">param-value</span>&gt;</span> <span class=\"hljs-comment\">&lt;!--设置你想用的字符集，我这里用的是UTF-8--&gt;</span>\r\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">init-param</span>&gt;</span>\r\n        <span class=\"hljs-comment\">&lt;!--强制使用该编码--&gt;</span>\r\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">init-param</span>&gt;</span>\r\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">param-name</span>&gt;</span>forceEncoding<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">param-name</span>&gt;</span>\r\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">param-value</span>&gt;</span>true<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">param-value</span>&gt;</span>\r\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">init-param</span>&gt;</span>\r\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">filter</span>&gt;</span>\r\n\r\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">filter-mapping</span>&gt;</span>\r\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">filter-name</span>&gt;</span>encodingFilter<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">filter-name</span>&gt;</span>\r\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">url-pattern</span>&gt;</span>/*<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">url-pattern</span>&gt;</span> <span class=\"hljs-comment\">&lt;!--设置你想过滤的页面或者是Servlet，根据自己的需要配置--&gt;</span>\r\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">filter-mapping</span>&gt;</span>\r\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">web-app</span>&gt;</span></code></pre>\r\n\r\n<ul>\r\n<li>ApplicationContent.xml(Spring配置文件)</li>\r\n</ul>\r\n\r\n<pre class=\"prettyprint hljs-dark\"><code class=\" hljs xml\"><span class=\"hljs-pi\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span>\r\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">beans</span> <span class=\"hljs-attribute\">xmlns</span>=<span class=\"hljs-value\">\"http://www.springframework.org/schema/beans\"</span>\r\n       <span class=\"hljs-attribute\">xmlns:xsi</span>=<span class=\"hljs-value\">\"http://www.w3.org/2001/XMLSchema-instance\"</span>\r\n       <span class=\"hljs-attribute\">xsi:schemaLocation</span>=<span class=\"hljs-value\">\"http://www.springframework.org/schema/beans \r\n       http://www.springframework.org/schema/beans/spring-beans.xsd\"</span>&gt;</span>\r\n\r\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">beans</span>&gt;</span></code></pre>\r\n\r\n<ul>\r\n<li>dispatchce-servlet.xml(SpringMVC配置文件)</li>\r\n</ul>\r\n\r\n<pre class=\"prettyprint hljs-dark\"><code class=\" hljs xml\"><span class=\"hljs-pi\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span>\r\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">beans</span> <span class=\"hljs-attribute\">xmlns</span>=<span class=\"hljs-value\">\"http://www.springframework.org/schema/beans\"</span>\r\n       <span class=\"hljs-attribute\">xmlns:xsi</span>=<span class=\"hljs-value\">\"http://www.w3.org/2001/XMLSchema-instance\"</span>\r\n       <span class=\"hljs-attribute\">xsi:schemaLocation</span>=<span class=\"hljs-value\">\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"</span>&gt;</span>\r\n\r\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">beans</span>&gt;</span></code></pre>\r\n\r\n<hr>\r\n\r\n<h2 id=\"p\">4.修改Spring MVC配置文件</h2>\r\n\r\n<p>修改前需要在WEB-INF下的lib中引入jstl的三个包,并且在WEB-INF中建立static文件夹,该文件夹中建立css,js,images三个子文件夹,然后按照如下配置</p>\r\n\r\n<pre class=\"prettyprint hljs-dark\"><code class=\" hljs xml\"><span class=\"hljs-pi\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span>\r\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">beans</span> <span class=\"hljs-attribute\">xmlns</span>=<span class=\"hljs-value\">\"http://www.springframework.org/schema/beans\"</span>\r\n       <span class=\"hljs-attribute\">xmlns:xsi</span>=<span class=\"hljs-value\">\"http://www.w3.org/2001/XMLSchema-instance\"</span> <span class=\"hljs-attribute\">xmlns:mvc</span>=<span class=\"hljs-value\">\"http://www.springframework.org/schema/mvc\"</span>\r\n       <span class=\"hljs-attribute\">xmlns:content</span>=<span class=\"hljs-value\">\"http://www.springframework.org/schema/context\"</span>\r\n       <span class=\"hljs-attribute\">xsi:schemaLocation</span>=<span class=\"hljs-value\">\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"</span>&gt;</span>\r\n\r\n    <span class=\"hljs-comment\">&lt;!-- 自动扫描该包，使SpringMVC认为包下用了@controller注解的类是控制器 --&gt;</span>\r\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">content:component-scan</span> <span class=\"hljs-attribute\">base-package</span>=<span class=\"hljs-value\">\"main.java.controller\"</span>/&gt;</span>\r\n\r\n    <span class=\"hljs-comment\">&lt;!-- 配置注解驱动 --&gt;</span>\r\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">mvc:annotation-driven</span>/&gt;</span>\r\n\r\n    <span class=\"hljs-comment\">&lt;!-- 对模型视图名称的解析，即在模型视图名称添加前后缀(如果最后一个还是表示文件夹,则最后的斜杠不要漏了) 使用JSP--&gt;</span>\r\n    <span class=\"hljs-comment\">&lt;!-- 默认的视图解析器 在上边的解析错误时使用 (默认使用html)- --&gt;</span>\r\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">bean</span> <span class=\"hljs-attribute\">id</span>=<span class=\"hljs-value\">\"defaultViewResolver\"</span> <span class=\"hljs-attribute\">class</span>=<span class=\"hljs-value\">\"org.springframework.web.servlet.view.InternalResourceViewResolver\"</span>&gt;</span>\r\n        <span class=\"hljs-comment\">&lt;!--可以使用jstl标签--&gt;</span>\r\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">property</span> <span class=\"hljs-attribute\">name</span>=<span class=\"hljs-value\">\"viewClass\"</span> <span class=\"hljs-attribute\">value</span>=<span class=\"hljs-value\">\"org.springframework.web.servlet.view.JstlView\"</span>/&gt;</span>\r\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">property</span> <span class=\"hljs-attribute\">name</span>=<span class=\"hljs-value\">\"prefix\"</span> <span class=\"hljs-attribute\">value</span>=<span class=\"hljs-value\">\"/WEB-INF/jsp/\"</span>/&gt;</span><span class=\"hljs-comment\">&lt;!--设置JSP文件的目录位置--&gt;</span>\r\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">property</span> <span class=\"hljs-attribute\">name</span>=<span class=\"hljs-value\">\"suffix\"</span> <span class=\"hljs-attribute\">value</span>=<span class=\"hljs-value\">\".jsp\"</span>/&gt;</span>\r\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">bean</span>&gt;</span>\r\n\r\n    <span class=\"hljs-comment\">&lt;!--静态资源映射--&gt;</span>\r\n    <span class=\"hljs-comment\">&lt;!--\r\n    表示当浏览器有静态资源请求的时候，并且请求url路径中带有：/js/，则这个资源跑到webapp目录下的/WEB-INF/statics/js/去找\r\n    比如我们在 JSP 中引入一个 js 文件：src=\"${webRoot}/js/jQuery-core/jquery-1.6.1.min.js\r\n    两个*表示当前文件夹及其子文件夹都可访问\r\n    --&gt;</span>\r\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">mvc:resources</span> <span class=\"hljs-attribute\">mapping</span>=<span class=\"hljs-value\">\"/css/**\"</span> <span class=\"hljs-attribute\">location</span>=<span class=\"hljs-value\">\"/WEB-INF/static/css/\"</span>/&gt;</span>\r\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">mvc:resources</span> <span class=\"hljs-attribute\">mapping</span>=<span class=\"hljs-value\">\"/js/**\"</span> <span class=\"hljs-attribute\">location</span>=<span class=\"hljs-value\">\"/WEB-INF/static/js/\"</span>/&gt;</span>\r\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">mvc:resources</span> <span class=\"hljs-attribute\">mapping</span>=<span class=\"hljs-value\">\"/images/**\"</span> <span class=\"hljs-attribute\">location</span>=<span class=\"hljs-value\">\"/WEB-INF/static/images/\"</span>/&gt;</span>\r\n\r\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">beans</span>&gt;</span></code></pre>\r\n\r\n<hr>\r\n\r\n<h2 id=\"title-3\">5.实现一个简单的Hello World</h2>\r\n\r\n<p>对此不解释,只是简单实现例子,下一篇开始学习controller</p>\r\n\r\n<p>首先建立一个HelloController.java,让其跳转到hello.jsp</p>\r\n\r\n<pre class=\"prettyprint hljs-dark\"><code class=\" hljs java\"><span class=\"hljs-keyword\">import</span> org.springframework.stereotype.Controller;\r\n<span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.RequestMapping;\r\n<span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.RequestMethod;\r\n\r\n<span class=\"hljs-javadoc\">/**\r\n * Created by nl101 on 2016/4/4.\r\n */</span>\r\n<span class=\"hljs-annotation\">@Controller</span>\r\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HelloController</span> {</span>\r\n\r\n    <span class=\"hljs-annotation\">@RequestMapping</span>(value = <span class=\"hljs-string\">\"/hello\"</span>,method = RequestMethod.GET)\r\n    <span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">hello</span>(){\r\n\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"hello\"</span>;\r\n    }\r\n}</code></pre>\r\n\r\n<p>其次在WEB-INF–jsp下建立hello.jsp,写上Hello World</p>\r\n\r\n<pre class=\"prettyprint hljs-dark\"><code class=\" hljs xml\"><span class=\"vbscript\">&lt;%@ page contentType=<span class=\"hljs-string\">\"text/html;charset=UTF-8\"</span> language=<span class=\"hljs-string\">\"java\"</span> %&gt;</span>\r\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">html</span>&gt;</span>\r\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">head</span>&gt;</span>\r\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">title</span>&gt;</span>Title<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">title</span>&gt;</span>\r\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">head</span>&gt;</span>\r\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">body</span>&gt;</span>\r\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">h1</span> <span class=\"hljs-attribute\">style</span>=<span class=\"hljs-value\">\"text-align: center\"</span>&gt;</span>Hello World!<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">h1</span>&gt;</span>\r\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">body</span>&gt;</span>\r\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">html</span>&gt;</span></code></pre>\r\n\r\n<p>启动tomcat,访问localhost:8888/hello(数字是你tomcat的端口号)</p>\r\n\r\n<p><img src=\"http://img.blog.csdn.net/20160404150426454\" alt=\"这里写图片描述\" title=\"\"></p>\r\n\r\n<p>此时整个项目结构如下,希望对大家有帮助 <br>\r\n<img src=\"http://img.blog.csdn.net/20160404150613970\" alt=\"这里写图片描述\" title=\"\"></p>','在IDEA下配置SpringMVC环境是相当简单的,这里强烈推荐Intellij IDEA开发javaWEB简直完爆eclipse.\r\n\r\n\r\n----------\r\n\r\n1.创建项目\r\n------\r\n创建项目很简单,直接选择SpringMVC即可,并且IDEA会自动配置Spring的架包\r\n![这里写图片描述](http://img.blog.csdn.net/20160404134234985)\r\n\r\n创建后的项目结构如下:\r\n![这里写图片描述](http://img.blog.csdn.net/20160404134818300)\r\n\r\n\r\n----------\r\n\r\n2.基本配置和tomcat服务器配置\r\n------------------\r\n首先在WEB-INF文件夹中建立lib文件夹,用于放我们自己的包,然后在Project Structure里面加入我们的包和tomcat的包\r\n![这里写图片描述](http://img.blog.csdn.net/20160404142948737)\r\n\r\n然后在运行那里配置tomcat服务器\r\n![这里写图片描述](http://img.blog.csdn.net/20160404143224395)\r\n\r\n到此环境算配置完毕,其他很多工作IDEA都帮我们做好了,下面分析下IDEA做的那些配置\r\n\r\n\r\n----------\r\n\r\n3.各种xml文件配置\r\n-----------\r\n\r\n* web.xml\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"\r\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n         xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd\"\r\n         version=\"3.1\">\r\n    <!--指定spring的配置文件所在的目录-->\r\n    <context-param>\r\n        <param-name>contextConfigLocation</param-name>\r\n        <param-value>/WEB-INF/applicationContext.xml</param-value>\r\n    </context-param>\r\n    <!--设置spring监听器-->\r\n    <listener>\r\n        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\r\n    </listener>\r\n    <!--配置springMVC,这里的servlet名称决定着SpringMVC配置文件的名称-->\r\n    <servlet>\r\n        <servlet-name>dispatcher</servlet-name>\r\n        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\r\n        <!--启动时加载,1代表优先级,越小代表越高-->\r\n        <load-on-startup>1</load-on-startup>\r\n    </servlet>\r\n    <servlet-mapping>\r\n        <servlet-name>dispatcher</servlet-name>\r\n        <!--这里修改为全部页面-->\r\n        <url-pattern>/</url-pattern>\r\n    </servlet-mapping>\r\n\r\n<!--配置请求编码(这一部分是手动配置的)-->\r\n    <filter>\r\n        <filter-name>encodingFilter</filter-name>\r\n        <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>\r\n        <init-param>\r\n            <param-name>encoding</param-name>\r\n            <param-value>UTF-8</param-value> <!--设置你想用的字符集，我这里用的是UTF-8-->\r\n        </init-param>\r\n        <!--强制使用该编码-->\r\n        <init-param>\r\n            <param-name>forceEncoding</param-name>\r\n            <param-value>true</param-value>\r\n        </init-param>\r\n    </filter>\r\n\r\n    <filter-mapping>\r\n        <filter-name>encodingFilter</filter-name>\r\n        <url-pattern>/*</url-pattern> <!--设置你想过滤的页面或者是Servlet，根据自己的需要配置-->\r\n    </filter-mapping>\r\n</web-app>\r\n```\r\n* ApplicationContent.xml(Spring配置文件)\r\n\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans \r\n       http://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n\r\n</beans>\r\n```\r\n* dispatchce-servlet.xml(SpringMVC配置文件)\r\n\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n\r\n</beans>\r\n```\r\n\r\n\r\n----------\r\n\r\n4.修改Spring MVC配置文件\r\n------------------\r\n修改前需要在WEB-INF下的lib中引入jstl的三个包,并且在WEB-INF中建立static文件夹,该文件夹中建立css,js,images三个子文件夹,然后按照如下配置\r\n\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\r\n       xmlns:content=\"http://www.springframework.org/schema/context\"\r\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\">\r\n\r\n    <!-- 自动扫描该包，使SpringMVC认为包下用了@controller注解的类是控制器 -->\r\n    <content:component-scan base-package=\"main.java.controller\"/>\r\n   \r\n    <!-- 配置注解驱动 -->\r\n    <mvc:annotation-driven/>\r\n\r\n    <!-- 对模型视图名称的解析，即在模型视图名称添加前后缀(如果最后一个还是表示文件夹,则最后的斜杠不要漏了) 使用JSP-->\r\n    <!-- 默认的视图解析器 在上边的解析错误时使用 (默认使用html)- -->\r\n    <bean id=\"defaultViewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">\r\n        <!--可以使用jstl标签-->\r\n        <property name=\"viewClass\" value=\"org.springframework.web.servlet.view.JstlView\"/>\r\n        <property name=\"prefix\" value=\"/WEB-INF/jsp/\"/><!--设置JSP文件的目录位置-->\r\n        <property name=\"suffix\" value=\".jsp\"/>\r\n    </bean>\r\n\r\n    <!--静态资源映射-->\r\n    <!--\r\n    表示当浏览器有静态资源请求的时候，并且请求url路径中带有：/js/，则这个资源跑到webapp目录下的/WEB-INF/statics/js/去找\r\n    比如我们在 JSP 中引入一个 js 文件：src=\"${webRoot}/js/jQuery-core/jquery-1.6.1.min.js\r\n    两个*表示当前文件夹及其子文件夹都可访问\r\n    -->\r\n    <mvc:resources mapping=\"/css/**\" location=\"/WEB-INF/static/css/\"/>\r\n    <mvc:resources mapping=\"/js/**\" location=\"/WEB-INF/static/js/\"/>\r\n    <mvc:resources mapping=\"/images/**\" location=\"/WEB-INF/static/images/\"/>\r\n\r\n</beans>\r\n```\r\n\r\n\r\n----------\r\n\r\n5.实现一个简单的Hello World\r\n--------------------\r\n对此不解释,只是简单实现例子,下一篇开始学习controller\r\n\r\n首先建立一个HelloController.java,让其跳转到hello.jsp\r\n\r\n```\r\nimport org.springframework.stereotype.Controller;\r\nimport org.springframework.web.bind.annotation.RequestMapping;\r\nimport org.springframework.web.bind.annotation.RequestMethod;\r\n\r\n/**\r\n * Created by nl101 on 2016/4/4.\r\n */\r\n@Controller\r\npublic class HelloController {\r\n    \r\n    @RequestMapping(value = \"/hello\",method = RequestMethod.GET)\r\n    public String hello(){\r\n        \r\n        return \"hello\";\r\n    }\r\n}\r\n```\r\n\r\n其次在WEB-INF--jsp下建立hello.jsp,写上Hello World\r\n\r\n```\r\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\r\n<html>\r\n<head>\r\n    <title>Title</title>\r\n</head>\r\n<body>\r\n    <h1 style=\"text-align: center\">Hello World!</h1>\r\n</body>\r\n</html>\r\n```\r\n\r\n启动tomcat,访问localhost:8888/hello(数字是你tomcat的端口号)\r\n\r\n![这里写图片描述](http://img.blog.csdn.net/20160404150426454)\r\n\r\n此时整个项目结构如下,希望对大家有帮助\r\n![这里写图片描述](http://img.blog.csdn.net/20160404150613970)\r\n','SpringMVC',2,2,9,0,1,'2016-10-05 11:31:02','2016-10-05 11:31:04',1,NULL,NULL),
	(2,'SpringMVC学习记录(二)--controller和view的联系',1,'对于SpringMVC来说,controller由两个部分构成,分别是分发器和控制器,分发器DispatcherServlet决定着请求使用哪个控制器,并且决定着控制器返回哪个视图,整体结构如下. 1.创建一个controller对于DispatcherServlet这个是springMVC框架自动实现,而我们只需要写相应的控制器即可,就拿上一个helloworld例子来说,创建一个控制器,只需要...','<p>对于SpringMVC来说,controller由两个部分构成,分别是分发器和控制器,分发器<strong>DispatcherServlet</strong>决定着请求使用哪个控制器,并且决定着控制器返回哪个视图,整体结构如下. <br>\r\n<img src=\"http://img.blog.csdn.net/20160404153729232\" alt=\"这里写图片描述\" title=\"\"></p>\r\n\r\n<hr>\r\n\r\n<h2 id=\"title\">1.创建一个controller</h2>\r\n\r\n<p>对于<strong>DispatcherServlet</strong>这个是springMVC框架自动实现,而我们只需要写相应的控制器即可,就拿上一个helloworld例子来说,创建一个控制器,只需要给其加上<strong>@controller</strong>的注解</p>\r\n\r\n<pre class=\"prettyprint hljs-dark\"><code class=\" hljs java\"><span class=\"hljs-javadoc\">/**\r\n * 加上@Controller决定这个类是一个控制器\r\n */</span>\r\n<span class=\"hljs-annotation\">@Controller</span>\r\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HelloController</span> {</span>\r\n\r\n    <span class=\"hljs-annotation\">@RequestMapping</span>(value = <span class=\"hljs-string\">\"/hello\"</span>,method = RequestMethod.GET)\r\n    <span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">hello</span>(){\r\n\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"hello\"</span>;\r\n    }\r\n}</code></pre>\r\n\r\n<p><strong>@Controller</strong> 用于标记在一个类上，使用它标记的类就是一个SpringMVC Controller 对象。分发处理器将会扫描使用了该注解的类的方法，并检测该方法是否使用了<strong>@RequestMapping</strong> 注解。<strong>@Controller</strong> 只是定义了一个控制器类，而使用<strong>@RequestMapping</strong> 注解的方法才是真正处理请求的处理器，这个接下来就会讲到。 <br>\r\n让控制器起作用,则需要在springMVC.xml配置文件中配置,也就是上一篇搭建基本环境中的配置 <br>\r\n<img src=\"http://img.blog.csdn.net/20160404154209312\" alt=\"这里写图片描述\" title=\"\"></p>\r\n\r\n<hr>\r\n\r\n<h2 id=\"p\">2.让controller返回一个jsp视图</h2>\r\n\r\n<p><strong>@RequestMapping</strong> 注解决定着返回的jsp视图,对于这个属性先简单来说一般配置value和method两个值,value决定着请求的路径,method决定着请求的方法</p>\r\n\r\n<pre class=\"prettyprint hljs-dark\"><code class=\" hljs java\"><span class=\"hljs-annotation\">@Controller</span>\r\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HelloController</span> {</span>\r\n\r\n    <span class=\"hljs-annotation\">@RequestMapping</span>(value = <span class=\"hljs-string\">\"/hello\"</span>,method = RequestMethod.GET)\r\n    <span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">hello</span>(){\r\n\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"hello\"</span>;\r\n    }\r\n}</code></pre>\r\n\r\n<p>拿上面例子来说,直接在浏览器访问localhost:8888/hello即可访问到这个控制器,对应的请求为GET请求,此方法返回一个hello字符串,说明对应的视图为hello.jsp,这是最简单的访问形式,<strong>如果我们想要传值的话,该怎么做呢?</strong></p>\r\n\r\n<ul>\r\n<li>方法1:在参数中加一个model,直接把值放进去就可以了</li>\r\n</ul>\r\n\r\n<pre class=\"prettyprint hljs-dark\"><code class=\" hljs java\">  <span class=\"hljs-annotation\">@RequestMapping</span>(value = <span class=\"hljs-string\">\"/hello\"</span>,method = RequestMethod.GET)\r\n    <span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">hello</span>(Model model){\r\n<span class=\"hljs-comment\">//        这样放参数的话,在jsp中直接用EL访问hello即可</span>\r\n        model.addAttribute(<span class=\"hljs-string\">\"hello\"</span>,<span class=\"hljs-string\">\"world1\"</span>);\r\n<span class=\"hljs-comment\">//        这样方参数的话,默认的key是参数类型</span>\r\n        model.addAttribute(<span class=\"hljs-string\">\"world2\"</span>);\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"hello\"</span>;\r\n    }</code></pre>\r\n\r\n<p>在对应的jsp中可以如下获取</p>\r\n\r\n<pre class=\"prettyprint hljs-dark\"><code class=\" hljs xml\"><span class=\"vbscript\">&lt;%@ page contentType=<span class=\"hljs-string\">\"text/html;charset=UTF-8\"</span> language=<span class=\"hljs-string\">\"java\"</span> %&gt;</span>\r\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">html</span>&gt;</span>\r\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">head</span>&gt;</span>\r\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">title</span>&gt;</span>Title<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">title</span>&gt;</span>\r\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">head</span>&gt;</span>\r\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">body</span>&gt;</span>\r\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">h1</span> <span class=\"hljs-attribute\">style</span>=<span class=\"hljs-value\">\"text-align: center\"</span>&gt;</span>Hello World!${hello}----${string}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">h1</span>&gt;</span>\r\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">body</span>&gt;</span>\r\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">html</span>&gt;</span></code></pre>\r\n\r\n<p><img src=\"http://img.blog.csdn.net/20160404155355004\" alt=\"这里写图片描述\" title=\"\"></p>\r\n\r\n<ul>\r\n<li>方法2;使用ModelAndView </li>\r\n</ul>\r\n\r\n<pre class=\"prettyprint hljs-dark\"><code class=\" hljs java\">    <span class=\"hljs-annotation\">@RequestMapping</span>(value = <span class=\"hljs-string\">\"/hello\"</span>,method = RequestMethod.GET)\r\n    <span class=\"hljs-keyword\">public</span> ModelAndView <span class=\"hljs-title\">hello</span>(){\r\n        ModelAndView model = <span class=\"hljs-keyword\">new</span> ModelAndView();\r\n        <span class=\"hljs-comment\">//设置返回视图名称</span>\r\n        model.setViewName(<span class=\"hljs-string\">\"hello\"</span>);\r\n        <span class=\"hljs-comment\">//传值,规则同上</span>\r\n        model.addObject(<span class=\"hljs-string\">\"hello\"</span>,<span class=\"hljs-string\">\"world1\"</span>);\r\n        <span class=\"hljs-comment\">//传值,规则同上</span>\r\n        model.addObject(<span class=\"hljs-string\">\"world2\"</span>);\r\n        <span class=\"hljs-keyword\">return</span> model;\r\n    }</code></pre>\r\n\r\n<p>两种方法几乎没区别,根据爱好使用. <br>\r\n<img src=\"http://img.blog.csdn.net/20160404155355004\" alt=\"这里写图片描述\" title=\"\"></p>\r\n\r\n<hr>\r\n\r\n<h2 id=\"title-1\">3.使用URI模板</h2>\r\n\r\n<p>URI模板是用来获取url中的值,看下面小例子</p>\r\n\r\n<pre class=\"prettyprint hljs-dark\"><code class=\" hljs java\"><span class=\"hljs-annotation\">@RequestMapping</span>(value = <span class=\"hljs-string\">\"/hello/{id}\"</span>,method = RequestMethod.GET)\r\n    <span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">hello</span>(@<span class=\"hljs-title\">PathVariable</span>(\"id\") String id, Model model){\r\n<span class=\"hljs-comment\">//        这样放参数的话,在jsp中直接用EL访问hello即可</span>\r\n        model.addAttribute(<span class=\"hljs-string\">\"hello\"</span>,id);\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"hello\"</span>;\r\n    }</code></pre>\r\n\r\n<p>上面在value = “/hello/{id}”,说明访问的url必须为/hello/XX这样的链接,@PathVariable(“id”) String id,的作用就是把这个XX放入id中,然后jsp页面就可以获取这个值了 <br>\r\n<img src=\"http://img.blog.csdn.net/20160404160748619\" alt=\"这里写图片描述\" title=\"\"></p>\r\n\r\n<p>除此之外还支持*通配符访问</p>\r\n\r\n<pre class=\"prettyprint hljs-dark\"><code class=\" hljs java\"><span class=\"hljs-annotation\">@Controller</span>\r\n<span class=\"hljs-annotation\">@RequestMapping</span> ( <span class=\"hljs-string\">\"/myTest\"</span> )\r\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyController</span> {</span>\r\n    <span class=\"hljs-annotation\">@RequestMapping</span> ( <span class=\"hljs-string\">\"*/wildcard\"</span> )\r\n    <span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">testWildcard</span>() {\r\n       System. out .println( <span class=\"hljs-string\">\"wildcard------------\"</span> );\r\n       <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"wildcard\"</span> ;\r\n    }  \r\n} </code></pre>\r\n\r\n<p>那么此时的访问路径只要为/mytest/**/wildcard都可以访问当前连接</p>\r\n\r\n<hr>\r\n\r\n<h2 id=\"p-p\">4.@RequestParam 绑定 HttpServletRequest 请求参数</h2>\r\n\r\n<pre class=\"prettyprint hljs-dark\"><code class=\" hljs java\">    <span class=\"hljs-annotation\">@RequestMapping</span> ( <span class=\"hljs-string\">\"requestParam\"</span> )\r\n   <span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">testRequestParam</span>( @<span class=\"hljs-title\">RequestParam</span>(required=<span class=\"hljs-keyword\">false</span>) String name, <span class=\"hljs-annotation\">@RequestParam</span> ( <span class=\"hljs-string\">\"age\"</span> ) <span class=\"hljs-keyword\">int</span> age) {\r\n       <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"requestParam\"</span> ;\r\n    } </code></pre>\r\n\r\n<p>required=false代表name是非必须值,可以不存在HttpServletRequest 之中,而后面的age则不同,要求必须在HttpServletRequest 之中,否则会报错. <br>\r\n值得注意的是和@PathVariable 一样，当你没有明确指定从request 中取哪个参数时，Spring 在代码是debug 编译的情况下会默认取更方法参数同名的参数，如果不是debug 编译的就会报错。此外，当需要从request 中绑定的参数和方法的参数名不相同的时候，也需要在@RequestParam 中明确指出是要绑定哪个参数。 <br>\r\n类似的还有@CookieValue,@RequestHeader都类似用法,不过一般不用这种方法,接着看下面RequestMapping 的高级用法.</p>\r\n\r\n<hr>\r\n\r\n<h2 id=\"pp\">5.RequestMapping 的高级用法</h2>\r\n\r\n<h3 id=\"title-2\">1.支持的方法参数类型</h3>\r\n\r\n<ol>\r\n<li>HttpServlet 对象，主要包括HttpServletRequest 、HttpServletResponse 和HttpSession 对象。 这些参数Spring 在调用处理器方法的时候会自动给它们赋值，所以当在处理器方法中需要使用到这些对象的时候，可以直接在方法上给定一个方法参数的申明，然后在方法体里面直接用就可以了。但是有一点需要注意的是在使用HttpSession 对象的时候，如果此时HttpSession 对象还没有建立起来的话就会有问题。</li>\r\n<li>Spring 自己的WebRequest 对象。 使用该对象可以访问到存放在HttpServletRequest 和HttpSession 中的属性值。</li>\r\n<li>InputStream 、OutputStream 、Reader 和Writer 。 InputStream 和Reader 是针对HttpServletRequest 而言的，可以从里面取数据；OutputStream 和Writer 是针对HttpServletResponse 而言的，可以往里面写数据。</li>\r\n<li>使用@PathVariable 、@RequestParam 、@CookieValue 和@RequestHeader 标记的参数。</li>\r\n<li>使用@ModelAttribute 标记的参数。</li>\r\n<li>java.util.Map 、Spring 封装的Model 和ModelMap 。 这些都可以用来封装模型数据，用来给视图做展示。</li>\r\n<li>实体类。 可以用来接收上传的参数。</li>\r\n<li>Spring 封装的MultipartFile 。 用来接收上传文件的。</li>\r\n<li>Spring 封装的Errors 和BindingResult 对象。 这两个对象参数必须紧接在需要验证的实体对象参数之后，它里面包含了实体对象的验证结果。</li>\r\n</ol>\r\n\r\n<h3 id=\"title-3\">2.支持的返回类型</h3>\r\n\r\n<ol>\r\n<li>一个包含模型和视图的ModelAndView 对象。</li>\r\n<li>一个模型对象，这主要包括Spring 封装好的Model 和ModelMap ，以及java.util.Map ，当没有视图返回的时候视图名称将由RequestToViewNameTranslator 来决定。</li>\r\n<li>一个View 对象。这个时候如果在渲染视图的过程中模型的话就可以给处理器方法定义一个模型参数，然后在方法体里面往模型中添加值。</li>\r\n<li>一个String 字符串。这往往代表的是一个视图名称。这个时候如果需要在渲染视图的过程中需要模型的话就可以给处理器方法一个模型参数，然后在方法体里面往模型中添加值就可以了。</li>\r\n<li>返回值是void 。这种情况一般是我们直接把返回结果写到HttpServletResponse 中了，如果没有写的话，那么Spring 将会利用RequestToViewNameTranslator 来返回一个对应的视图名称。如果视图中需要模型的话，处理方法与返回字符串的情况相同。</li>\r\n<li>如果处理器方法被注解@ResponseBody 标记的话，那么处理器方法的任何返回类型都会通过HttpMessageConverters 转换之后写到HttpServletResponse 中，而不会像上面的那些情况一样当做视图或者模型来处理。</li>\r\n<li>除以上几种情况之外的其他任何返回类型都会被当做模型中的一个属性来处理，而返回的视图还是由RequestToViewNameTranslator 来决定，添加到模型中的属性名称可以在该方法上用@ModelAttribute(“attributeName”) 来定义，否则将使用返回类型的类名称的首字母小写形式来表示。使用@ModelAttribute 标记的方法会在@RequestMapping 标记的方法执行之前执行。</li>\r\n</ol>\r\n\r\n<p>对于方法参数,就像使用Model传值一样,可以直接在参数中加入req,resp,session等,然后就像servlet那样使用就可以了</p>\r\n\r\n<pre class=\"prettyprint hljs-dark\"><code class=\" hljs java\"> <span class=\"hljs-annotation\">@RequestMapping</span>(value = <span class=\"hljs-string\">\"/hello\"</span>,method = RequestMethod.GET)\r\n    <span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">hello</span>(Model model, HttpServletRequest request, HttpServletResponse response, HttpSession session){\r\n<span class=\"hljs-comment\">//        这样放参数的话,在jsp中直接用EL访问hello即可</span>\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"hello\"</span>;\r\n    }</code></pre>\r\n\r\n<hr>\r\n\r\n<h2 id=\"title-4\">6.定义自己的转换器</h2>\r\n\r\n<p>在通过处理器方法参数接收 request 请求参数绑定数据的时候，对于一些简单的数据类型 Spring 会帮我们自动进行类型转换，而对于一些复杂的类型由于 Spring 没法识别，所以也就不能帮助我们进行自动转换了，这个时候如果我们需要 Spring 来帮我们自动转换的话就需要我们给 Spring 注册一个对特定类型的识别转换器。 Spring 允许我们提供两种类型的识别转换器，一种是注册在 Controller 中的，一种是注册在 SpringMVC 的配置文件中。聪明的读者看到这里应该可以想到它们的区别了，定义在 Controller 中的是局部的，只在当前 Controller 中有效，而放在 SpringMVC 配置文件中的是全局的，所有 Controller 都可以拿来使用。</p>\r\n\r\n<ul>\r\n<li>局部转换器</li>\r\n</ul>\r\n\r\n<pre class=\"prettyprint hljs-dark\"><code class=\" hljs java\">    <span class=\"hljs-annotation\">@InitBinder</span>\r\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">initBinder</span>(WebDataBinder binder){\r\n        DateFormat format = <span class=\"hljs-keyword\">new</span> SimpleDateFormat(<span class=\"hljs-string\">\"yyyy-MM-dd\"</span>);\r\n        PropertyEditor propertyEditor = <span class=\"hljs-keyword\">new</span> CustomDateEditor(format, <span class=\"hljs-keyword\">true</span> ); <span class=\"hljs-comment\">// 第二个参数表示是否允许为空  </span>\r\n        binder.registerCustomEditor(Date.class, propertyEditor);\r\n    }</code></pre>\r\n\r\n<p><img src=\"http://img.blog.csdn.net/20160404164908400\" alt=\"这里写图片描述\" title=\"\"></p>\r\n\r\n<ul>\r\n<li>全局转换器</li>\r\n</ul>\r\n\r\n<pre class=\"prettyprint hljs-dark\"><code class=\" hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyWebBindingInitializer</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">WebBindingInitializer</span> {</span>\r\n\r\n    <span class=\"hljs-annotation\">@Override</span>\r\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">initBinder</span>(WebDataBinder binder, WebRequest request) {\r\n       <span class=\"hljs-comment\">// TODO Auto-generated method stub</span>\r\n       DateFormat dateFormat = <span class=\"hljs-keyword\">new</span> SimpleDateFormat( <span class=\"hljs-string\">\"yyyyMMdd\"</span> );\r\n       PropertyEditor propertyEditor = <span class=\"hljs-keyword\">new</span> CustomDateEditor(dateFormat, <span class=\"hljs-keyword\">true</span> );\r\n       binder.registerCustomEditor(Date. class , propertyEditor);\r\n    }\r\n\r\n} </code></pre>\r\n\r\n<p>需要在springMVC.xml中引入这个转换器</p>\r\n\r\n<pre class=\"prettyprint hljs-dark\"><code class=\" hljs applescript\">    &lt; bean <span class=\"hljs-type\">class</span> = <span class=\"hljs-string\">\"org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter\"</span> &gt;\r\n       &lt; <span class=\"hljs-keyword\">property</span> <span class=\"hljs-property\">name</span> = <span class=\"hljs-string\">\"webBindingInitializer\"</span> &gt;\r\n           &lt; bean <span class=\"hljs-type\">class</span> = <span class=\"hljs-string\">\"com.host.app.web.util.MyWebBindingInitializer\"</span> /&gt;\r\n       &lt;/ <span class=\"hljs-keyword\">property</span> &gt;\r\n    &lt;/ bean &gt; </code></pre>\r\n\r\n<p>剩下的用法没区别了</p>\r\n\r\n<hr>\r\n\r\n<p>待补充</p>','对于SpringMVC来说,controller由两个部分构成,分别是分发器和控制器,分发器**DispatcherServlet**决定着请求使用哪个控制器,并且决定着控制器返回哪个视图,整体结构如下.\r\n![这里写图片描述](http://img.blog.csdn.net/20160404153729232)\r\n\r\n\r\n----------\r\n\r\n1.创建一个controller\r\n----------------\r\n对于**DispatcherServlet**这个是springMVC框架自动实现,而我们只需要写相应的控制器即可,就拿上一个helloworld例子来说,创建一个控制器,只需要给其加上**@controller**的注解\r\n\r\n```\r\n/**\r\n * 加上@Controller决定这个类是一个控制器\r\n */\r\n@Controller\r\npublic class HelloController {\r\n\r\n    @RequestMapping(value = \"/hello\",method = RequestMethod.GET)\r\n    public String hello(){\r\n\r\n        return \"hello\";\r\n    }\r\n}\r\n```\r\n\r\n**@Controller** 用于标记在一个类上，使用它标记的类就是一个SpringMVC Controller 对象。分发处理器将会扫描使用了该注解的类的方法，并检测该方法是否使用了**@RequestMapping** 注解。**@Controller** 只是定义了一个控制器类，而使用**@RequestMapping** 注解的方法才是真正处理请求的处理器，这个接下来就会讲到。\r\n让控制器起作用,则需要在springMVC.xml配置文件中配置,也就是上一篇搭建基本环境中的配置\r\n![这里写图片描述](http://img.blog.csdn.net/20160404154209312)\r\n\r\n\r\n----------\r\n\r\n2.让controller返回一个jsp视图\r\n----------------------\r\n**@RequestMapping** 注解决定着返回的jsp视图,对于这个属性先简单来说一般配置value和method两个值,value决定着请求的路径,method决定着请求的方法\r\n\r\n```\r\n@Controller\r\npublic class HelloController {\r\n\r\n    @RequestMapping(value = \"/hello\",method = RequestMethod.GET)\r\n    public String hello(){\r\n\r\n        return \"hello\";\r\n    }\r\n}\r\n```\r\n拿上面例子来说,直接在浏览器访问localhost:8888/hello即可访问到这个控制器,对应的请求为GET请求,此方法返回一个hello字符串,说明对应的视图为hello.jsp,这是最简单的访问形式,**如果我们想要传值的话,该怎么做呢?**\r\n\r\n* 方法1:在参数中加一个model,直接把值放进去就可以了\r\n	\r\n\r\n```\r\n  @RequestMapping(value = \"/hello\",method = RequestMethod.GET)\r\n    public String hello(Model model){\r\n//        这样放参数的话,在jsp中直接用EL访问hello即可\r\n        model.addAttribute(\"hello\",\"world1\");\r\n//        这样方参数的话,默认的key是参数类型\r\n        model.addAttribute(\"world2\");\r\n        return \"hello\";\r\n    }\r\n```\r\n在对应的jsp中可以如下获取\r\n\r\n```\r\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\r\n<html>\r\n<head>\r\n    <title>Title</title>\r\n</head>\r\n<body>\r\n    <h1 style=\"text-align: center\">Hello World!${hello}----${string}</h1>\r\n</body>\r\n</html>\r\n```\r\n![这里写图片描述](http://img.blog.csdn.net/20160404155355004)\r\n\r\n* 方法2;使用ModelAndView \r\n\r\n```\r\n    @RequestMapping(value = \"/hello\",method = RequestMethod.GET)\r\n    public ModelAndView hello(){\r\n        ModelAndView model = new ModelAndView();\r\n        //设置返回视图名称\r\n        model.setViewName(\"hello\");\r\n        //传值,规则同上\r\n        model.addObject(\"hello\",\"world1\");\r\n        //传值,规则同上\r\n        model.addObject(\"world2\");\r\n        return model;\r\n    }\r\n```\r\n两种方法几乎没区别,根据爱好使用.\r\n![这里写图片描述](http://img.blog.csdn.net/20160404155355004)\r\n\r\n\r\n----------\r\n\r\n3.使用URI模板\r\n---------\r\nURI模板是用来获取url中的值,看下面小例子\r\n```\r\n@RequestMapping(value = \"/hello/{id}\",method = RequestMethod.GET)\r\n    public String hello(@PathVariable(\"id\") String id, Model model){\r\n//        这样放参数的话,在jsp中直接用EL访问hello即可\r\n        model.addAttribute(\"hello\",id);\r\n        return \"hello\";\r\n    }\r\n```\r\n上面在value = \"/hello/{id}\",说明访问的url必须为/hello/XX这样的链接,@PathVariable(\"id\") String id,的作用就是把这个XX放入id中,然后jsp页面就可以获取这个值了\r\n![这里写图片描述](http://img.blog.csdn.net/20160404160748619)\r\n\r\n除此之外还支持*通配符访问\r\n\r\n```\r\n@Controller\r\n@RequestMapping ( \"/myTest\" )\r\npublic class MyController {\r\n    @RequestMapping ( \"*/wildcard\" )\r\n    public String testWildcard() {\r\n       System. out .println( \"wildcard------------\" );\r\n       return \"wildcard\" ;\r\n    }  \r\n} \r\n```\r\n那么此时的访问路径只要为/mytest/**/wildcard都可以访问当前连接\r\n\r\n\r\n----------\r\n\r\n4.@RequestParam 绑定 HttpServletRequest 请求参数\r\n------------------------------------------\r\n\r\n```\r\n    @RequestMapping ( \"requestParam\" )\r\n   public String testRequestParam( @RequestParam(required=false) String name, @RequestParam ( \"age\" ) int age) {\r\n       return \"requestParam\" ;\r\n    } \r\n```\r\nrequired=false代表name是非必须值,可以不存在HttpServletRequest 之中,而后面的age则不同,要求必须在HttpServletRequest 之中,否则会报错.\r\n值得注意的是和@PathVariable 一样，当你没有明确指定从request 中取哪个参数时，Spring 在代码是debug 编译的情况下会默认取更方法参数同名的参数，如果不是debug 编译的就会报错。此外，当需要从request 中绑定的参数和方法的参数名不相同的时候，也需要在@RequestParam 中明确指出是要绑定哪个参数。\r\n类似的还有@CookieValue,@RequestHeader都类似用法,不过一般不用这种方法,接着看下面RequestMapping 的高级用法.\r\n\r\n\r\n----------\r\n\r\n5.RequestMapping 的高级用法\r\n----------------------\r\n\r\n###1.支持的方法参数类型\r\n1. HttpServlet 对象，主要包括HttpServletRequest 、HttpServletResponse 和HttpSession 对象。 这些参数Spring 在调用处理器方法的时候会自动给它们赋值，所以当在处理器方法中需要使用到这些对象的时候，可以直接在方法上给定一个方法参数的申明，然后在方法体里面直接用就可以了。但是有一点需要注意的是在使用HttpSession 对象的时候，如果此时HttpSession 对象还没有建立起来的话就会有问题。\r\n2. Spring 自己的WebRequest 对象。 使用该对象可以访问到存放在HttpServletRequest 和HttpSession 中的属性值。\r\n3. InputStream 、OutputStream 、Reader 和Writer 。 InputStream 和Reader 是针对HttpServletRequest 而言的，可以从里面取数据；OutputStream 和Writer 是针对HttpServletResponse 而言的，可以往里面写数据。\r\n4. 使用@PathVariable 、@RequestParam 、@CookieValue 和@RequestHeader 标记的参数。\r\n5. 使用@ModelAttribute 标记的参数。\r\n6. java.util.Map 、Spring 封装的Model 和ModelMap 。 这些都可以用来封装模型数据，用来给视图做展示。\r\n7. 实体类。 可以用来接收上传的参数。\r\n8. Spring 封装的MultipartFile 。 用来接收上传文件的。\r\n9. Spring 封装的Errors 和BindingResult 对象。 这两个对象参数必须紧接在需要验证的实体对象参数之后，它里面包含了实体对象的验证结果。\r\n###2.支持的返回类型\r\n\r\n1. 一个包含模型和视图的ModelAndView 对象。\r\n2. 一个模型对象，这主要包括Spring 封装好的Model 和ModelMap ，以及java.util.Map ，当没有视图返回的时候视图名称将由RequestToViewNameTranslator 来决定。\r\n3. 一个View 对象。这个时候如果在渲染视图的过程中模型的话就可以给处理器方法定义一个模型参数，然后在方法体里面往模型中添加值。\r\n4. 一个String 字符串。这往往代表的是一个视图名称。这个时候如果需要在渲染视图的过程中需要模型的话就可以给处理器方法一个模型参数，然后在方法体里面往模型中添加值就可以了。\r\n5. 返回值是void 。这种情况一般是我们直接把返回结果写到HttpServletResponse 中了，如果没有写的话，那么Spring 将会利用RequestToViewNameTranslator 来返回一个对应的视图名称。如果视图中需要模型的话，处理方法与返回字符串的情况相同。\r\n6. 如果处理器方法被注解@ResponseBody 标记的话，那么处理器方法的任何返回类型都会通过HttpMessageConverters 转换之后写到HttpServletResponse 中，而不会像上面的那些情况一样当做视图或者模型来处理。\r\n7. 除以上几种情况之外的其他任何返回类型都会被当做模型中的一个属性来处理，而返回的视图还是由RequestToViewNameTranslator 来决定，添加到模型中的属性名称可以在该方法上用@ModelAttribute(“attributeName”) 来定义，否则将使用返回类型的类名称的首字母小写形式来表示。使用@ModelAttribute 标记的方法会在@RequestMapping 标记的方法执行之前执行。\r\n\r\n对于方法参数,就像使用Model传值一样,可以直接在参数中加入req,resp,session等,然后就像servlet那样使用就可以了\r\n\r\n```\r\n @RequestMapping(value = \"/hello\",method = RequestMethod.GET)\r\n    public String hello(Model model, HttpServletRequest request, HttpServletResponse response, HttpSession session){\r\n//        这样放参数的话,在jsp中直接用EL访问hello即可\r\n        return \"hello\";\r\n    }\r\n```\r\n\r\n\r\n----------\r\n\r\n6.定义自己的转换器\r\n----------\r\n\r\n在通过处理器方法参数接收 request 请求参数绑定数据的时候，对于一些简单的数据类型 Spring 会帮我们自动进行类型转换，而对于一些复杂的类型由于 Spring 没法识别，所以也就不能帮助我们进行自动转换了，这个时候如果我们需要 Spring 来帮我们自动转换的话就需要我们给 Spring 注册一个对特定类型的识别转换器。 Spring 允许我们提供两种类型的识别转换器，一种是注册在 Controller 中的，一种是注册在 SpringMVC 的配置文件中。聪明的读者看到这里应该可以想到它们的区别了，定义在 Controller 中的是局部的，只在当前 Controller 中有效，而放在 SpringMVC 配置文件中的是全局的，所有 Controller 都可以拿来使用。\r\n\r\n* 局部转换器\r\n```\r\n    @InitBinder\r\n    public void initBinder(WebDataBinder binder){\r\n        DateFormat format = new SimpleDateFormat(\"yyyy-MM-dd\");\r\n        PropertyEditor propertyEditor = new CustomDateEditor(format, true ); // 第二个参数表示是否允许为空  \r\n        binder.registerCustomEditor(Date.class, propertyEditor);\r\n    }\r\n```\r\n![这里写图片描述](http://img.blog.csdn.net/20160404164908400)\r\n\r\n* 全局转换器\r\n\r\n```\r\npublic class MyWebBindingInitializer implements WebBindingInitializer {\r\n\r\n    @Override\r\n    public void initBinder(WebDataBinder binder, WebRequest request) {\r\n       // TODO Auto-generated method stub\r\n       DateFormat dateFormat = new SimpleDateFormat( \"yyyyMMdd\" );\r\n       PropertyEditor propertyEditor = new CustomDateEditor(dateFormat, true );\r\n       binder.registerCustomEditor(Date. class , propertyEditor);\r\n    }\r\n\r\n} \r\n```\r\n需要在springMVC.xml中引入这个转换器\r\n\r\n```\r\n    < bean class = \"org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter\" >\r\n       < property name = \"webBindingInitializer\" >\r\n           < bean class = \"com.host.app.web.util.MyWebBindingInitializer\" />\r\n       </ property >\r\n    </ bean > \r\n```\r\n剩下的用法没区别了\r\n\r\n\r\n----------\r\n待补充','SpringMVC',1,1,9,0,1,'2016-10-05 11:38:02','2016-10-05 11:38:03',1,NULL,NULL),
	(3,'SpringMVC学习记录(三)--异常处理',1,'学习springMVC从大牛那借鉴了很多经验,感谢ITEYE的大牛springMVC提供的异常处理主要有两种方式，一种是直接实现自己的HandlerExceptionResolver，当然这也包括使用Spring已经为我们提供好的SimpleMappingExceptionResolver和DefaultHandlerExceptionResolver，另一种是使用注解的方式实现一个专门用于处理异常...','<p>学习springMVC从大牛那借鉴了很多经验,感谢<a href=\"http://haohaoxuexi.iteye.com/\">ITEYE的大牛</a></p>\r\n\r\n<hr>\r\n\r\n<p>springMVC提供的异常处理主要有两种方式，一种是直接实现自己的<strong>HandlerExceptionResolver</strong>，当然这也包括使用Spring已经为我们提供好的<strong>SimpleMappingExceptionResolver</strong>和<strong>DefaultHandlerExceptionResolver</strong>，另一种是使用注解的方式实现一个专门用于处理异常的<strong>Controller——ExceptionHandler</strong>。和之前一样,前者相当于全局管理的异常,后者只针对当前<strong>controller</strong>有效</p>\r\n\r\n<hr>\r\n\r\n<h2 id=\"title\">1.全局异常</h2>\r\n\r\n<h3 id=\"title-1\">1.创建异常并配置</h3>\r\n\r\n<p>首先定义一个全局异常类,可以看出这个类会把异常打印在控制台,并且放入model中,以便可以在jsp页面上展示出来</p>\r\n\r\n<pre class=\"prettyprint hljs-dark\"><code class=\" hljs java\"><span class=\"hljs-keyword\">import</span> javax.servlet.http.HttpServletRequest;\r\n<span class=\"hljs-keyword\">import</span> javax.servlet.http.HttpServletResponse;\r\n\r\n<span class=\"hljs-keyword\">import</span> org.springframework.web.servlet.HandlerExceptionResolver;\r\n<span class=\"hljs-keyword\">import</span> org.springframework.web.servlet.ModelAndView;\r\n\r\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyExceptionResolver</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">HandlerExceptionResolver</span>{</span>\r\n\r\n    <span class=\"hljs-keyword\">public</span> ModelAndView <span class=\"hljs-title\">resolveException</span>(HttpServletRequest request,\r\n            HttpServletResponse response, Object handler, Exception ex) {\r\n\r\n        System.out.println(<span class=\"hljs-string\">\"==============异常开始=============\"</span>);\r\n        ex.printStackTrace();\r\n        System.out.println(<span class=\"hljs-string\">\"==============异常结束=============\"</span>);\r\n        <span class=\"hljs-comment\">//设置返回页面为error.jsp</span>\r\n        ModelAndView mv = <span class=\"hljs-keyword\">new</span> ModelAndView(<span class=\"hljs-string\">\"error\"</span>);\r\n        mv.addObject(<span class=\"hljs-string\">\"exception\"</span>, ex.toString().replaceAll(<span class=\"hljs-string\">\"\\n\"</span>, <span class=\"hljs-string\">\"&lt;br/&gt;\"</span>));\r\n        <span class=\"hljs-keyword\">return</span> mv;\r\n    }\r\n}</code></pre>\r\n\r\n<p>然后在error.jsp中显示异常</p>\r\n\r\n<pre class=\"prettyprint hljs-dark\"><code class=\" hljs xml\"><span class=\"vbscript\">&lt;%@ page language=<span class=\"hljs-string\">\"java\"</span> contentType=<span class=\"hljs-string\">\"text/html; charset=UTF-8\"</span> pageEncoding=<span class=\"hljs-string\">\"UTF-8\"</span>%&gt;</span>\r\n<span class=\"vbscript\">&lt;%@ taglib prefix=<span class=\"hljs-string\">\"c\"</span> uri=<span class=\"hljs-string\">\"http://java.sun.com/jsp/jstl/core\"</span>%&gt;</span>\r\n<span class=\"hljs-doctype\">&lt;!DOCTYPE html&gt;</span>\r\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">html</span> <span class=\"hljs-attribute\">lang</span>=<span class=\"hljs-value\">\"en\"</span>&gt;</span>\r\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">head</span>&gt;</span>\r\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">meta</span> <span class=\"hljs-attribute\">charset</span>=<span class=\"hljs-value\">\"utf-8\"</span> /&gt;</span>\r\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">title</span>&gt;</span>应用程序异常 (500)<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">title</span>&gt;</span> \r\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">head</span>&gt;</span> \r\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">body</span>&gt;</span> \r\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">div</span>&gt;</span> \r\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">h1</span>&gt;</span>应用程序异常<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">h1</span>&gt;</span> \r\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">p</span>&gt;</span>抱歉！您访问的页面出现异常，请稍后重试或联系管理员。<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">p</span>&gt;</span> \r\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">p</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">a</span> <span class=\"hljs-attribute\">href</span>=<span class=\"hljs-value\">\"#\"</span>&gt;</span>详 情<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">a</span>&gt;</span> \r\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">a</span> <span class=\"hljs-attribute\">href</span>=<span class=\"hljs-value\">\"javascript:history.back(-1)\"</span>&gt;</span>返 回<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">a</span>&gt;</span> \r\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">p</span>&gt;</span> \r\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">div</span> <span class=\"hljs-attribute\">style</span>=<span class=\"hljs-value\">\"display:none;text-align: left;\"</span> <span class=\"hljs-attribute\">id</span>=<span class=\"hljs-value\">\"err\"</span>&gt;</span>${exception }<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">div</span>&gt;</span>\r\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">div</span>&gt;</span>\r\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">body</span>&gt;</span> \r\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">html</span>&gt;</span></code></pre>\r\n\r\n<p>接着在springMVC.xml中配置这个异常</p>\r\n\r\n<pre class=\"prettyprint hljs-dark\"><code class=\" hljs xml\">    <span class=\"hljs-comment\">&lt;!--配置全局异常类--&gt;</span>\r\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">bean</span> <span class=\"hljs-attribute\">id</span>=<span class=\"hljs-value\">\"exceptionResolver\"</span> <span class=\"hljs-attribute\">class</span>=<span class=\"hljs-value\">\"main.java.controller.MyExceptionResolver\"</span>/&gt;</span></code></pre>\r\n\r\n<h3 id=\"title-2\">2.使用上面的异常</h3>\r\n\r\n<p>在控制器里面模拟调用</p>\r\n\r\n<pre class=\"prettyprint hljs-dark\"><code class=\" hljs java\">    <span class=\"hljs-annotation\">@RequestMapping</span>(value = <span class=\"hljs-string\">\"/hello\"</span>,method = RequestMethod.GET)\r\n    <span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">hello</span>(Model model){\r\n        String str = <span class=\"hljs-string\">\"asbd123\"</span>;\r\n        <span class=\"hljs-comment\">//这里会报NumberFormatException异常,然后spring会自动捕捉这个异常</span>\r\n        <span class=\"hljs-keyword\">int</span> a = Integer.parseInt(str);\r\n\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"hello\"</span>;\r\n    }</code></pre>\r\n\r\n<p>然后访问localhost:8888/hello,页面就会显示如下 <br>\r\n<img src=\"http://img.blog.csdn.net/20160404190715797\" alt=\"这里写图片描述\" title=\"\"></p>\r\n\r\n<p>同样的再控制台会输出我们的异常信息 <br>\r\n<img src=\"http://img.blog.csdn.net/20160404190739516\" alt=\"这里写图片描述\" title=\"\"></p>\r\n\r\n<p>到此这就是一个全局异常.</p>\r\n\r\n<hr>\r\n\r\n<h2 id=\"title-3\">2.局部异常处理</h2>\r\n\r\n<p>局部异常使用使用@ExceptionHandler进行处理,具体如下</p>\r\n\r\n<p><font color=\"red\">使用@ExceptionHandler进行处理有一个不好的地方是进行异常处理的方法必须与出错的方法在同一个Controller里面</font></p>\r\n\r\n<pre class=\"prettyprint hljs-dark\"><code class=\" hljs java\">   <span class=\"hljs-comment\">//创建处理异常的类,这个类会处理当前控制器下的Myexception这个异常</span>\r\n    <span class=\"hljs-annotation\">@ExceptionHandler</span>(Myexception.class)\r\n    <span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">getError</span>(Myexception myexception,Model model){\r\n        System.out.println(<span class=\"hljs-string\">\"==============异常开始=============\"</span>);\r\n        myexception.printStackTrace();\r\n        System.out.println(<span class=\"hljs-string\">\"==============异常结束=============\"</span>);\r\n        model.addAttribute(<span class=\"hljs-string\">\"exception\"</span>,myexception.getMessage());\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"error\"</span>;\r\n    }\r\n    <span class=\"hljs-comment\">//当前这个请求会抛出异常</span>\r\n    <span class=\"hljs-annotation\">@RequestMapping</span>(value = <span class=\"hljs-string\">\"/hello\"</span>,method = RequestMethod.GET)\r\n    <span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">hello</span>(Model model) <span class=\"hljs-keyword\">throws</span> Myexception {\r\n        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">true</span>){\r\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> Myexception(<span class=\"hljs-string\">\"出错了\"</span>);\r\n        }\r\n\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"hello\"</span>;\r\n    }</code></pre>\r\n\r\n<p>对应的JSP视图中会显示出相应的错误信息</p>\r\n\r\n<p><img src=\"http://img.blog.csdn.net/20160404191859786\" alt=\"这里写图片描述\" title=\"\"></p>\r\n\r\n<p>对应的控制台也会输出相应的信息</p>\r\n\r\n<p><img src=\"http://img.blog.csdn.net/20160404191940161\" alt=\"这里写图片描述\" title=\"\"></p>\r\n\r\n<hr>\r\n\r\n<h2 id=\"title-4\">3.异常优先级</h2>\r\n\r\n<p>既然在SpringMVC中有两种处理异常的方式，那么就存在一个优先级的问题： <br>\r\n当发生异常的时候，SpringMVC会如下处理：</p>\r\n\r\n<ol>\r\n<li>SpringMVC会先从配置文件找异常解析器HandlerExceptionResolver</li>\r\n<li>如果找到了异常异常解析器，那么接下来就会判断该异常解析器能否处理当前发生的异常</li>\r\n<li>如果可以处理的话，那么就进行处理，然后给前台返回对应的异常视图</li>\r\n<li>如果没有找到对应的异常解析器或者是找到的异常解析器不能处理当前的异常的时候，就看当前的Controller中有没有提供对应的异常处理器，如果提供了就由Controller自己进行处理并返回对应的视图</li>\r\n<li>如果配置文件里面没有定义对应的异常解析器，而当前Controller中也没有定义的话，那么该异常就会被抛出来。</li>\r\n</ol>\r\n\r\n<hr>\r\n\r\n<h2 id=\"p\">4.spring提供的异常模板</h2>\r\n\r\n<p>Spring实现了一个SimpleMappingExceptionResolver，这两者都是继承自抽象类<strong>AbstractHandlerExceptionResolver</strong>，而AbstractHandlerExceptionResolver是实现了HandlerExceptionResolver接口的resolveException方法的，并由此抽取出两个抽象方法，一个是在<strong>进行异常处理之前执行</strong>的方法prepareResponse(exception, response)，一个是<strong>进行异常解析</strong>的doResolveException(request, response, handler, exception)方法。 <br>\r\nSimpleMappingExceptionResolver，顾名思义就是通过<strong>简单的映射关系</strong>来决定由哪个视图来处理当前的错误信息。SimpleMappingExceptionResolver提供了通过异常类型exceptionMappings来进行异常与视图之间的映射关系，提供了在发生异常时通过<strong>statusCodes</strong>来映射异常返回的视图名称和对应的HttpServletResponse的返回码。而且可以通过defaultErrorView和defaultErrorCode来指定默认值，<strong>defaultErrorView</strong>表示当没有在exceptionMappings里面找到对应的异常类型时就返回defaultErrorView定义的视图，<strong>defaultErrorCode</strong>表示在发生异常时当没有在视图与返回码的映射关系statusCodes里面找到对应的映射时默认返回的返回码。在使用SimpleMappingExceptionResolver时，当发生异常的时候，SimpleMappingExceptionResolver将会把当前的异常对象放到自身属性<strong>exceptionAttribute</strong>中，当没有指定exceptionAttribute时，exceptionAttribute就是用默认值exception。</p>\r\n\r\n<p>下面试一个其xml代码的简单配置</p>\r\n\r\n<pre class=\"prettyprint hljs-dark\"><code class=\" hljs xml\">    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">bean</span> <span class=\"hljs-attribute\">class</span>=<span class=\"hljs-value\">\"org.springframework.web.servlet.handler.SimpleMappingExceptionResolver\"</span>&gt;</span>\r\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">property</span> <span class=\"hljs-attribute\">name</span>=<span class=\"hljs-value\">\"exceptionMappings\"</span>&gt;</span>\r\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">props</span>&gt;</span>\r\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">prop</span> <span class=\"hljs-attribute\">key</span>=<span class=\"hljs-value\">\"NumberFormatException\"</span>&gt;</span>number<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">prop</span>&gt;</span><span class=\"hljs-comment\">&lt;!-- 表示当抛出NumberFormatException的时候就返回名叫number的视图 --&gt;</span>\r\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">prop</span> <span class=\"hljs-attribute\">key</span>=<span class=\"hljs-value\">\"NullPointerException\"</span>&gt;</span>null<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">prop</span>&gt;</span>\r\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">props</span>&gt;</span>\r\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">property</span>&gt;</span>\r\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">property</span> <span class=\"hljs-attribute\">name</span>=<span class=\"hljs-value\">\"defaultErrorView\"</span> <span class=\"hljs-attribute\">value</span>=<span class=\"hljs-value\">\"exception\"</span>/&gt;</span><span class=\"hljs-comment\">&lt;!-- 表示当抛出异常但没有在exceptionMappings里面找到对应的异常时 返回名叫exception的视图--&gt;</span>\r\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">property</span> <span class=\"hljs-attribute\">name</span>=<span class=\"hljs-value\">\"statusCodes\"</span>&gt;</span><span class=\"hljs-comment\">&lt;!-- 定义在发生异常时视图跟返回码的对应关系 --&gt;</span>\r\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">props</span>&gt;</span>\r\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">prop</span> <span class=\"hljs-attribute\">key</span>=<span class=\"hljs-value\">\"number\"</span>&gt;</span>500<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">prop</span>&gt;</span><span class=\"hljs-comment\">&lt;!-- 表示在发生NumberFormatException时返回视图number，然后这里定义发生异常时视图number对应的HttpServletResponse的返回码是500 --&gt;</span>\r\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">prop</span> <span class=\"hljs-attribute\">key</span>=<span class=\"hljs-value\">\"null\"</span>&gt;</span>503<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">prop</span>&gt;</span>\r\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">props</span>&gt;</span>\r\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">property</span>&gt;</span>\r\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">property</span> <span class=\"hljs-attribute\">name</span>=<span class=\"hljs-value\">\"defaultStatusCode\"</span> <span class=\"hljs-attribute\">value</span>=<span class=\"hljs-value\">\"404\"</span>/&gt;</span><span class=\"hljs-comment\">&lt;!-- 表示在发生异常时默认的HttpServletResponse的返回码是多少，默认是200 --&gt;</span>\r\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">bean</span>&gt;</span></code></pre>\r\n\r\n<p>下面是引发这些异常的测试代码</p>\r\n\r\n<pre class=\"prettyprint hljs-dark\"><code class=\" hljs java\"><span class=\"hljs-annotation\">@Controller</span>\r\n<span class=\"hljs-annotation\">@RequestMapping</span>(<span class=\"hljs-string\">\"/test\"</span>)\r\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TestController</span> {</span>\r\n\r\n    <span class=\"hljs-annotation\">@RequestMapping</span>(<span class=\"hljs-string\">\"/null\"</span>)\r\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">testNullPointerException</span>() {\r\n        Blog blog = <span class=\"hljs-keyword\">null</span>;\r\n        <span class=\"hljs-comment\">//这里就会发生空指针异常，然后就会返回定义在SpringMVC配置文件中的null视图</span>\r\n        System.out.println(blog.getId());\r\n    }\r\n\r\n    <span class=\"hljs-annotation\">@RequestMapping</span>(<span class=\"hljs-string\">\"/number\"</span>)\r\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">testNumberFormatException</span>() {\r\n        <span class=\"hljs-comment\">//这里就会发生NumberFormatException，然后就会返回定义在SpringMVC配置文件中的number视图</span>\r\n        Integer.parseInt(<span class=\"hljs-string\">\"abc\"</span>);\r\n    }\r\n\r\n    <span class=\"hljs-annotation\">@RequestMapping</span>(<span class=\"hljs-string\">\"/default\"</span>)\r\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">testDefaultException</span>() {\r\n        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-number\">1</span>==<span class=\"hljs-number\">1</span>)\r\n            <span class=\"hljs-comment\">//由于该异常类型在SpringMVC的配置文件中没有指定，所以就会返回默认的exception视图</span>\r\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> RuntimeException(<span class=\"hljs-string\">\"Error!\"</span>);\r\n    }\r\n\r\n}\r\n</code></pre>\r\n\r\n<p>最后在jsp页面中可以访问这些异常</p>\r\n\r\n<pre class=\"prettyprint hljs-dark\"><code class=\" hljs xml\"><span class=\"vbscript\">&lt;%@ page language=<span class=\"hljs-string\">\"java\"</span> import=<span class=\"hljs-string\">\"java.util.*\"</span> pageEncoding=<span class=\"hljs-string\">\"GB18030\"</span> isErrorPage=<span class=\"hljs-string\">\"true\"</span>%&gt;</span>\r\n<span class=\"vbscript\">&lt;%\r\n<span class=\"hljs-built_in\">String</span> path = <span class=\"hljs-built_in\">request</span>.getContextPath();\r\n<span class=\"hljs-built_in\">String</span> basePath = <span class=\"hljs-built_in\">request</span>.getScheme()+<span class=\"hljs-string\">\"://\"</span>+<span class=\"hljs-built_in\">request</span>.getServerName()+<span class=\"hljs-string\">\":\"</span>+<span class=\"hljs-built_in\">request</span>.getServerPort()+path+<span class=\"hljs-string\">\"/\"</span>;\r\n%&gt;</span>\r\n\r\n<span class=\"hljs-doctype\">&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"&gt;</span>\r\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">html</span>&gt;</span>\r\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">head</span>&gt;</span>\r\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">base</span> <span class=\"hljs-attribute\">href</span>=<span class=\"hljs-value\">\"&lt;%=basePath%&gt;\"</span>&gt;</span>\r\n\r\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">title</span>&gt;</span>My JSP \'number.jsp\' starting page<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">title</span>&gt;</span>\r\n\r\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">meta</span> <span class=\"hljs-attribute\">http-equiv</span>=<span class=\"hljs-value\">\"pragma\"</span> <span class=\"hljs-attribute\">content</span>=<span class=\"hljs-value\">\"no-cache\"</span>&gt;</span>\r\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">meta</span> <span class=\"hljs-attribute\">http-equiv</span>=<span class=\"hljs-value\">\"cache-control\"</span> <span class=\"hljs-attribute\">content</span>=<span class=\"hljs-value\">\"no-cache\"</span>&gt;</span>\r\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">meta</span> <span class=\"hljs-attribute\">http-equiv</span>=<span class=\"hljs-value\">\"expires\"</span> <span class=\"hljs-attribute\">content</span>=<span class=\"hljs-value\">\"0\"</span>&gt;</span>    \r\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">meta</span> <span class=\"hljs-attribute\">http-equiv</span>=<span class=\"hljs-value\">\"keywords\"</span> <span class=\"hljs-attribute\">content</span>=<span class=\"hljs-value\">\"keyword1,keyword2,keyword3\"</span>&gt;</span>\r\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">meta</span> <span class=\"hljs-attribute\">http-equiv</span>=<span class=\"hljs-value\">\"description\"</span> <span class=\"hljs-attribute\">content</span>=<span class=\"hljs-value\">\"This is my page\"</span>&gt;</span>\r\n    <span class=\"hljs-comment\">&lt;!--\r\n    &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"styles.css\"&gt;\r\n    --&gt;</span>\r\n\r\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">head</span>&gt;</span>\r\n\r\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">body</span>&gt;</span>\r\n    NumberFormatException. <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">br</span>&gt;</span>\r\n    <span class=\"vbscript\">&lt;%=exception.getMessage() %&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">br</span>/&gt;</span>\r\n    <span class=\"vbscript\">&lt;%=exception %&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">br</span>/&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">span</span> <span class=\"hljs-attribute\">style</span>=<span class=\"hljs-value\">\"color: #3366ff;\"</span>&gt;</span><span class=\"hljs-comment\">&lt;!-- 这是JSP中的内置对象exception --&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">span</span>&gt;</span>\r\n\r\n\r\n\r\n    <span class=\"vbscript\">&lt;%=<span class=\"hljs-built_in\">request</span>.getAttribute(<span class=\"hljs-string\">\"ex\"</span>) %&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">br</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">span</span> <span class=\"hljs-attribute\">style</span>=<span class=\"hljs-value\">\"color: #3366ff;\"</span>&gt;</span><span class=\"hljs-comment\">&lt;!-- 这是SpringMVC放在返回的Model中的异常对象 --&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">span</span>&gt;</span>\r\n\r\n\r\n\r\n    <span class=\"vbscript\">&lt;%=<span class=\"hljs-built_in\">request</span>.getAttribute(<span class=\"hljs-string\">\"javax.servlet.error.status_code\"</span>) %&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">span</span> <span class=\"hljs-attribute\">style</span>=<span class=\"hljs-value\">\"color: #3366ff;\"</span>&gt;</span><span class=\"hljs-comment\">&lt;!-- HttpServletResponse返回的错误码信息，因为前面已经配置了NumberFormatException的错误码返回值为888，所以这里应该显示888 --&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">span</span>&gt;</span>\r\n\r\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">body</span>&gt;</span>\r\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">html</span>&gt;</span>\r\n</code></pre>','学习springMVC从大牛那借鉴了很多经验,感谢[ITEYE的大牛](http://haohaoxuexi.iteye.com/)\r\n\r\n\r\n----------\r\n\r\n\r\nspringMVC提供的异常处理主要有两种方式，一种是直接实现自己的**HandlerExceptionResolver**，当然这也包括使用Spring已经为我们提供好的**SimpleMappingExceptionResolver**和**DefaultHandlerExceptionResolver**，另一种是使用注解的方式实现一个专门用于处理异常的**Controller——ExceptionHandler**。和之前一样,前者相当于全局管理的异常,后者只针对当前**controller**有效\r\n\r\n\r\n----------\r\n\r\n\r\n1.全局异常\r\n------\r\n###1.创建异常并配置\r\n首先定义一个全局异常类,可以看出这个类会把异常打印在控制台,并且放入model中,以便可以在jsp页面上展示出来\r\n\r\n```\r\nimport javax.servlet.http.HttpServletRequest;\r\nimport javax.servlet.http.HttpServletResponse;\r\n\r\nimport org.springframework.web.servlet.HandlerExceptionResolver;\r\nimport org.springframework.web.servlet.ModelAndView;\r\n\r\npublic class MyExceptionResolver implements HandlerExceptionResolver{\r\n\r\n	public ModelAndView resolveException(HttpServletRequest request,\r\n			HttpServletResponse response, Object handler, Exception ex) {\r\n		\r\n		System.out.println(\"==============异常开始=============\");\r\n		ex.printStackTrace();\r\n		System.out.println(\"==============异常结束=============\");\r\n		//设置返回页面为error.jsp\r\n		ModelAndView mv = new ModelAndView(\"error\");\r\n		mv.addObject(\"exception\", ex.toString().replaceAll(\"\\n\", \"<br/>\"));\r\n		return mv;\r\n	}\r\n}\r\n```\r\n然后在error.jsp中显示异常\r\n\r\n```\r\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%>\r\n<%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\"%>\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n  <head>\r\n  <meta charset=\"utf-8\" />\r\n<title>应用程序异常 (500)</title> \r\n</head> \r\n<body> \r\n  <div> \r\n    <h1>应用程序异常</h1> \r\n    <p>抱歉！您访问的页面出现异常，请稍后重试或联系管理员。</p> \r\n    <p><a href=\"#\">详 情</a> \r\n<a href=\"javascript:history.back(-1)\">返 回</a> \r\n    </p> \r\n    <div style=\"display:none;text-align: left;\" id=\"err\">${exception }</div>\r\n  </div>\r\n</body> \r\n</html>\r\n```\r\n接着在springMVC.xml中配置这个异常\r\n\r\n```\r\n    <!--配置全局异常类-->\r\n    <bean id=\"exceptionResolver\" class=\"main.java.controller.MyExceptionResolver\"/>\r\n```\r\n###2.使用上面的异常\r\n在控制器里面模拟调用\r\n```\r\n    @RequestMapping(value = \"/hello\",method = RequestMethod.GET)\r\n    public String hello(Model model){\r\n        String str = \"asbd123\";\r\n        //这里会报NumberFormatException异常,然后spring会自动捕捉这个异常\r\n        int a = Integer.parseInt(str);\r\n\r\n        return \"hello\";\r\n    }\r\n```\r\n然后访问localhost:8888/hello,页面就会显示如下\r\n![这里写图片描述](http://img.blog.csdn.net/20160404190715797)\r\n\r\n同样的再控制台会输出我们的异常信息\r\n![这里写图片描述](http://img.blog.csdn.net/20160404190739516)\r\n\r\n到此这就是一个全局异常.\r\n\r\n\r\n----------\r\n\r\n2.局部异常处理\r\n--------\r\n局部异常使用使用@ExceptionHandler进行处理,具体如下\r\n\r\n<font color=red>使用@ExceptionHandler进行处理有一个不好的地方是进行异常处理的方法必须与出错的方法在同一个Controller里面</font>\r\n\r\n```\r\n   //创建处理异常的类,这个类会处理当前控制器下的Myexception这个异常\r\n    @ExceptionHandler(Myexception.class)\r\n    public String getError(Myexception myexception,Model model){\r\n        System.out.println(\"==============异常开始=============\");\r\n        myexception.printStackTrace();\r\n        System.out.println(\"==============异常结束=============\");\r\n        model.addAttribute(\"exception\",myexception.getMessage());\r\n        return \"error\";\r\n    }\r\n	//当前这个请求会抛出异常\r\n    @RequestMapping(value = \"/hello\",method = RequestMethod.GET)\r\n    public String hello(Model model) throws Myexception {\r\n        if (true){\r\n            throw new Myexception(\"出错了\");\r\n        }\r\n\r\n        return \"hello\";\r\n    }\r\n```\r\n对应的JSP视图中会显示出相应的错误信息\r\n\r\n![这里写图片描述](http://img.blog.csdn.net/20160404191859786)\r\n\r\n对应的控制台也会输出相应的信息\r\n\r\n![这里写图片描述](http://img.blog.csdn.net/20160404191940161)\r\n\r\n\r\n----------\r\n\r\n\r\n3.异常优先级\r\n-------\r\n\r\n既然在SpringMVC中有两种处理异常的方式，那么就存在一个优先级的问题：\r\n当发生异常的时候，SpringMVC会如下处理：\r\n\r\n1. SpringMVC会先从配置文件找异常解析器HandlerExceptionResolver\r\n2. 如果找到了异常异常解析器，那么接下来就会判断该异常解析器能否处理当前发生的异常\r\n3. 如果可以处理的话，那么就进行处理，然后给前台返回对应的异常视图\r\n4. 如果没有找到对应的异常解析器或者是找到的异常解析器不能处理当前的异常的时候，就看当前的Controller中有没有提供对应的异常处理器，如果提供了就由Controller自己进行处理并返回对应的视图\r\n5. 如果配置文件里面没有定义对应的异常解析器，而当前Controller中也没有定义的话，那么该异常就会被抛出来。\r\n\r\n\r\n----------\r\n\r\n\r\n4.spring提供的异常模板\r\n---------------\r\n\r\nSpring实现了一个SimpleMappingExceptionResolver，这两者都是继承自抽象类**AbstractHandlerExceptionResolver**，而AbstractHandlerExceptionResolver是实现了HandlerExceptionResolver接口的resolveException方法的，并由此抽取出两个抽象方法，一个是在**进行异常处理之前执行**的方法prepareResponse(exception, response)，一个是**进行异常解析**的doResolveException(request, response, handler, exception)方法。\r\nSimpleMappingExceptionResolver，顾名思义就是通过**简单的映射关系**来决定由哪个视图来处理当前的错误信息。SimpleMappingExceptionResolver提供了通过异常类型exceptionMappings来进行异常与视图之间的映射关系，提供了在发生异常时通过**statusCodes**来映射异常返回的视图名称和对应的HttpServletResponse的返回码。而且可以通过defaultErrorView和defaultErrorCode来指定默认值，**defaultErrorView**表示当没有在exceptionMappings里面找到对应的异常类型时就返回defaultErrorView定义的视图，**defaultErrorCode**表示在发生异常时当没有在视图与返回码的映射关系statusCodes里面找到对应的映射时默认返回的返回码。在使用SimpleMappingExceptionResolver时，当发生异常的时候，SimpleMappingExceptionResolver将会把当前的异常对象放到自身属性**exceptionAttribute**中，当没有指定exceptionAttribute时，exceptionAttribute就是用默认值exception。\r\n\r\n下面试一个其xml代码的简单配置\r\n\r\n```\r\n	<bean class=\"org.springframework.web.servlet.handler.SimpleMappingExceptionResolver\">\r\n		<property name=\"exceptionMappings\">\r\n			<props>\r\n				<prop key=\"NumberFormatException\">number</prop><!-- 表示当抛出NumberFormatException的时候就返回名叫number的视图 -->\r\n				<prop key=\"NullPointerException\">null</prop>\r\n			</props>\r\n		</property>\r\n		<property name=\"defaultErrorView\" value=\"exception\"/><!-- 表示当抛出异常但没有在exceptionMappings里面找到对应的异常时 返回名叫exception的视图-->\r\n		<property name=\"statusCodes\"><!-- 定义在发生异常时视图跟返回码的对应关系 -->\r\n			<props>\r\n				<prop key=\"number\">500</prop><!-- 表示在发生NumberFormatException时返回视图number，然后这里定义发生异常时视图number对应的HttpServletResponse的返回码是500 -->\r\n				<prop key=\"null\">503</prop>\r\n			</props>\r\n		</property>\r\n		<property name=\"defaultStatusCode\" value=\"404\"/><!-- 表示在发生异常时默认的HttpServletResponse的返回码是多少，默认是200 -->\r\n	</bean>\r\n```\r\n下面是引发这些异常的测试代码\r\n\r\n```\r\n@Controller\r\n@RequestMapping(\"/test\")\r\npublic class TestController {\r\n\r\n	@RequestMapping(\"/null\")\r\n	public void testNullPointerException() {\r\n		Blog blog = null;\r\n		//这里就会发生空指针异常，然后就会返回定义在SpringMVC配置文件中的null视图\r\n		System.out.println(blog.getId());\r\n	}\r\n	\r\n	@RequestMapping(\"/number\")\r\n	public void testNumberFormatException() {\r\n		//这里就会发生NumberFormatException，然后就会返回定义在SpringMVC配置文件中的number视图\r\n		Integer.parseInt(\"abc\");\r\n	}\r\n	\r\n	@RequestMapping(\"/default\")\r\n	public void testDefaultException() {\r\n		if (1==1)\r\n			//由于该异常类型在SpringMVC的配置文件中没有指定，所以就会返回默认的exception视图\r\n			throw new RuntimeException(\"Error!\");\r\n	}\r\n	\r\n}\r\n\r\n```\r\n最后在jsp页面中可以访问这些异常\r\n\r\n```\r\n<%@ page language=\"java\" import=\"java.util.*\" pageEncoding=\"GB18030\" isErrorPage=\"true\"%>\r\n<%\r\nString path = request.getContextPath();\r\nString basePath = request.getScheme()+\"://\"+request.getServerName()+\":\"+request.getServerPort()+path+\"/\";\r\n%>\r\n\r\n<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">\r\n<html>\r\n  <head>\r\n    <base href=\"<%=basePath%>\">\r\n    \r\n    <title>My JSP \'number.jsp\' starting page</title>\r\n    \r\n	<meta http-equiv=\"pragma\" content=\"no-cache\">\r\n	<meta http-equiv=\"cache-control\" content=\"no-cache\">\r\n	<meta http-equiv=\"expires\" content=\"0\">    \r\n	<meta http-equiv=\"keywords\" content=\"keyword1,keyword2,keyword3\">\r\n	<meta http-equiv=\"description\" content=\"This is my page\">\r\n	<!--\r\n	<link rel=\"stylesheet\" type=\"text/css\" href=\"styles.css\">\r\n	-->\r\n\r\n  </head>\r\n  \r\n  <body>\r\n    NumberFormatException. <br>\r\n    <%=exception.getMessage() %><br/>\r\n    <%=exception %><br/><span style=\"color: #3366ff;\"><!-- 这是JSP中的内置对象exception --></span>\r\n\r\n\r\n\r\n    <%=request.getAttribute(\"ex\") %><br><span style=\"color: #3366ff;\"><!-- 这是SpringMVC放在返回的Model中的异常对象 --></span>\r\n\r\n\r\n\r\n    <%=request.getAttribute(\"javax.servlet.error.status_code\") %><span style=\"color: #3366ff;\"><!-- HttpServletResponse返回的错误码信息，因为前面已经配置了NumberFormatException的错误码返回值为888，所以这里应该显示888 --></span>\r\n\r\n  </body>\r\n</html>\r\n\r\n```\r\n\r\n\r\n','SpringMVC',1,1,9,0,1,'2016-10-05 11:42:29','2016-10-05 11:42:31',1,NULL,NULL),
	(4,'SpringMVC学习记录(四)--文件上传与下载',1,'学习一个框架少不了学习文件上传和下载,原理来说上传和下载都是基本二进制流的转换,所以搞清楚了这一点就很容易理解上传和下载了在使用springMVC进行系统实现时，springMVC默认的解析器里面是没有加入对文件上传的解析的，这可以方便我们实现自己的文件上传。但如果你想使用springMVC对文件上传的解析器来处理文件上传的时候就需要在spring的applicationContext里面加上spr...','<p>学习一个框架少不了学习文件上传和下载,原理来说上传和下载都是基本二进制流的转换,所以搞清楚了这一点就很容易理解上传和下载了</p>\r\n\r\n<hr>\r\n\r\n<p>在使用springMVC进行系统实现时，springMVC默认的解析器里面是没有加入对文件上传的解析的，这可以方便我们实现自己的文件上传。但如果你想使用springMVC对文件上传的解析器来处理文件上传的时候就需要在spring的applicationContext里面加上springMVC提供的MultipartResolver的申明。这样之后，客户端每次进行请求的时候，springMVC都会检查request里面是否包含多媒体信息，如果包含了就会使用MultipartResolver进行解析,springMVC会使用一个支持文件处理的MultipartHttpServletRequest来包裹当前的HttpServletRequest，然后使用MultipartHttpServletRequest就可以对文件进行处理了。</p>\r\n\r\n<hr>\r\n\r\n<p></p><h1 id=\"title\"><strong>一.文件上传</strong><p></p>\r\n\r\n<hr>\r\n\r\n</h1><h2 id=\"title-1\">1.引入依赖包</h2>\r\n\r\n<p>文件上传需要额外引入包分别是</p>\r\n\r\n<ol>\r\n<li>commons-fileupload-1.3.1.jar</li>\r\n<li>commons-io-2.4.jar</li>\r\n</ol>\r\n\r\n<h2 id=\"p\">2.配置jsp页面</h2>\r\n\r\n<pre class=\"prettyprint hljs-dark\"><code class=\" hljs xml\"><span class=\"vbscript\">&lt;%@ page contentType=<span class=\"hljs-string\">\"text/html;charset=UTF-8\"</span> language=<span class=\"hljs-string\">\"java\"</span> %&gt;</span>\r\n<span class=\"vbscript\">&lt;%@taglib prefix=<span class=\"hljs-string\">\"sf\"</span> uri=<span class=\"hljs-string\">\"http://www.springframework.org/tags/form\"</span> %&gt;</span>\r\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">html</span>&gt;</span>\r\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">head</span>&gt;</span>\r\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">meta</span> <span class=\"hljs-attribute\">charset</span>=<span class=\"hljs-value\">\"utf-8\"</span>&gt;</span>\r\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">title</span>&gt;</span>用户登录<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">title</span>&gt;</span>\r\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">head</span>&gt;</span>\r\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">body</span>&gt;</span>\r\n    <span class=\"vbscript\">&lt;%--文件上传的话需要enctype=<span class=\"hljs-string\">\"multipart/form-data\"</span>--%&gt;</span>\r\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">sf:form</span> <span class=\"hljs-attribute\">modelAttribute</span>=<span class=\"hljs-value\">\"user\"</span> <span class=\"hljs-attribute\">method</span>=<span class=\"hljs-value\">\"post\"</span> <span class=\"hljs-attribute\">enctype</span>=<span class=\"hljs-value\">\"multipart/form-data\"</span>&gt;</span>\r\n        用户名:<span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">sf:input</span> <span class=\"hljs-attribute\">path</span>=<span class=\"hljs-value\">\"username\"</span>/&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">sf:errors</span> <span class=\"hljs-attribute\">path</span>=<span class=\"hljs-value\">\"username\"</span>/&gt;</span>\r\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">br</span>&gt;</span>\r\n        密码:<span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">sf:input</span> <span class=\"hljs-attribute\">path</span>=<span class=\"hljs-value\">\"password\"</span>/&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">sf:errors</span> <span class=\"hljs-attribute\">path</span>=<span class=\"hljs-value\">\"password\"</span>/&gt;</span>\r\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">br</span>&gt;</span>\r\n        昵称:<span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">sf:input</span> <span class=\"hljs-attribute\">path</span>=<span class=\"hljs-value\">\"nickname\"</span>/&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">sf:errors</span> <span class=\"hljs-attribute\">path</span>=<span class=\"hljs-value\">\"nickname\"</span>/&gt;</span>\r\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">br</span>&gt;</span>\r\n        <span class=\"vbscript\">&lt;%--这里设置文件上传--%&gt;</span>\r\n        文件:<span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">input</span> <span class=\"hljs-attribute\">type</span>=<span class=\"hljs-value\">\"file\"</span> <span class=\"hljs-attribute\">name</span>=<span class=\"hljs-value\">\"file\"</span>&gt;</span>\r\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">input</span> <span class=\"hljs-attribute\">type</span>=<span class=\"hljs-value\">\"submit\"</span> <span class=\"hljs-attribute\">value</span>=<span class=\"hljs-value\">\"提交\"</span>&gt;</span>\r\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">sf:form</span>&gt;</span>\r\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">body</span>&gt;</span>\r\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">html</span>&gt;</span></code></pre>\r\n\r\n<h2 id=\"title-2\">3.配置相应的控制器</h2>\r\n\r\n<pre class=\"prettyprint hljs-dark\"><code class=\"language-java hljs \"><span class=\"hljs-annotation\">@RequestMapping</span>(value = <span class=\"hljs-string\">\"/login\"</span>,method = RequestMethod.POST)\r\n    <span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">login</span>(@Validated User user, BindingResult br, Model model,@<span class=\"hljs-title\">RequestParam</span>(\"file\") MultipartFile file){\r\n        <span class=\"hljs-keyword\">if</span> (br.hasErrors()){\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"user/login\"</span>;\r\n        }\r\n        <span class=\"hljs-comment\">//分别获取的是变量名file---文件类型---文件名</span>\r\n        System.out.println(file.getName()+<span class=\"hljs-string\">\"---\"</span>+file.getContentType()+<span class=\"hljs-string\">\"---\"</span>+file.getOriginalFilename());\r\n        <span class=\"hljs-keyword\">try</span> {\r\n            <span class=\"hljs-keyword\">if</span> (!file.isEmpty()){\r\n            <span class=\"hljs-comment\">//使用StreamsAPI方式拷贝文件</span>\r\n                Streams.copy(file.getInputStream(),<span class=\"hljs-keyword\">new</span> FileOutputStream(<span class=\"hljs-string\">\"E:/temp/\"</span>+file.getOriginalFilename()),<span class=\"hljs-keyword\">true</span>);\r\n            }\r\n        } <span class=\"hljs-keyword\">catch</span> (IOException e) {\r\n            System.out.println(<span class=\"hljs-string\">\"文件上传失败\"</span>);\r\n            e.printStackTrace();\r\n        }\r\n        System.out.println(user.toString());\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"user/login\"</span>;\r\n    }</code></pre>\r\n\r\n<p>至此单个文件上传完成.</p>\r\n\r\n<h2 id=\"title-3\">4.多文件上传</h2>\r\n\r\n<p>多文件上传很简单,只需要把参数改为数组就可以了</p>\r\n\r\n<pre class=\"prettyprint hljs-dark\"><code class=\"language-java hljs \">    <span class=\"hljs-annotation\">@RequestMapping</span>(value = <span class=\"hljs-string\">\"/login\"</span>,method = RequestMethod.POST)\r\n    <span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">login</span>(@Validated User user, BindingResult br, Model model,@<span class=\"hljs-title\">RequestParam</span>(\"file\") MultipartFile[] file){\r\n        <span class=\"hljs-keyword\">if</span> (br.hasErrors()){\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"user/login\"</span>;\r\n        }\r\n        <span class=\"hljs-comment\">//这里对文件进行遍历</span>\r\n        <span class=\"hljs-keyword\">for</span> (MultipartFile mul:file){\r\n        <span class=\"hljs-comment\">//分别获取的是变量名file---文件类型---文件名</span>\r\n            System.out.println(mul.getName()+<span class=\"hljs-string\">\"---\"</span>+mul.getContentType()+<span class=\"hljs-string\">\"---\"</span>+mul.getOriginalFilename());\r\n            <span class=\"hljs-keyword\">try</span> {\r\n                <span class=\"hljs-keyword\">if</span> (!mul.isEmpty()){\r\n                    Streams.copy(mul.getInputStream(),<span class=\"hljs-keyword\">new</span> FileOutputStream(<span class=\"hljs-string\">\"E:/temp/\"</span>+mul.getOriginalFilename()),<span class=\"hljs-keyword\">true</span>);\r\n                }\r\n            } <span class=\"hljs-keyword\">catch</span> (IOException e) {\r\n                System.out.println(<span class=\"hljs-string\">\"文件上传失败\"</span>);\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n        System.out.println(user.toString());\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"user/login\"</span>;\r\n    }</code></pre>\r\n\r\n<hr>\r\n\r\n<p></p><h1 id=\"ppp\"><strong>二.文件下载</strong><p></p>\r\n\r\n<hr>\r\n\r\n<p>下载需要把文件转换成二进制流,然后让客户端读取这个二进制流写入到本机,这样就实现了下载功能.那么现在就要想两个问题:1.怎么把文件写成二进制流?  2.怎么把让客户端相应,开始下载?</p>\r\n\r\n<p>答案;</p>\r\n\r\n<ol>\r\n<li>写成二进制流可以用之前导入的上传组件提供的方法:<code>FileUtils.readFileToByteArray(file)</code></li>\r\n<li>让浏览器相应,则需要设置相应的<strong>httpHeader</strong>了,并且利用spring提供的ResponseEntity把返回值设置为header和响应内容</li>\r\n</ol>\r\n\r\n</h1><h2 id=\"title-4\">1.创建控制器代码</h2>\r\n\r\n<pre class=\"prettyprint hljs-dark\"><code class=\" hljs java\">            <span class=\"hljs-annotation\">@RequestMapping</span>(value = <span class=\"hljs-string\">\"/download\"</span>)\r\n            <span class=\"hljs-keyword\">public</span> ResponseEntity&lt;<span class=\"hljs-keyword\">byte</span>[]&gt; <span class=\"hljs-title\">download</span>() <span class=\"hljs-keyword\">throws</span> IOException {\r\n<span class=\"hljs-comment\">//                指定文件,必须是绝对路径</span>\r\n            File file = <span class=\"hljs-keyword\">new</span> File(<span class=\"hljs-string\">\"E:/temp/me-bg.jpg\"</span>);\r\n<span class=\"hljs-comment\">//                下载浏览器响应的那个文件名</span>\r\n            String dfileName = <span class=\"hljs-string\">\"1.jpg\"</span>;\r\n<span class=\"hljs-comment\">//                下面开始设置HttpHeaders,使得浏览器响应下载</span>\r\n            HttpHeaders headers = <span class=\"hljs-keyword\">new</span> HttpHeaders();\r\n<span class=\"hljs-comment\">//                设置响应方式</span>\r\n            headers.setContentType(MediaType.APPLICATION_OCTET_STREAM);\r\n<span class=\"hljs-comment\">//                设置响应文件</span>\r\n            headers.setContentDispositionFormData(<span class=\"hljs-string\">\"attachment\"</span>, dfileName);\r\n<span class=\"hljs-comment\">//                把文件以二进制形式写回</span>\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> ResponseEntity&lt;<span class=\"hljs-keyword\">byte</span>[]&gt;(FileUtils.readFileToByteArray(file), headers, HttpStatus.CREATED);\r\n        }</code></pre>\r\n\r\n<h2 id=\"title-5\">2.测试下载</h2>\r\n\r\n<p>访问指定的控制器就能触发下载了</p>\r\n\r\n<p><img src=\"http://img.blog.csdn.net/20160405143238952\" alt=\"这里写图片描述\" title=\"\"></p>','学习一个框架少不了学习文件上传和下载,原理来说上传和下载都是基本二进制流的转换,所以搞清楚了这一点就很容易理解上传和下载了\r\n\r\n\r\n----------\r\n\r\n\r\n在使用springMVC进行系统实现时，springMVC默认的解析器里面是没有加入对文件上传的解析的，这可以方便我们实现自己的文件上传。但如果你想使用springMVC对文件上传的解析器来处理文件上传的时候就需要在spring的applicationContext里面加上springMVC提供的MultipartResolver的申明。这样之后，客户端每次进行请求的时候，springMVC都会检查request里面是否包含多媒体信息，如果包含了就会使用MultipartResolver进行解析,springMVC会使用一个支持文件处理的MultipartHttpServletRequest来包裹当前的HttpServletRequest，然后使用MultipartHttpServletRequest就可以对文件进行处理了。\r\n\r\n\r\n----------\r\n<h1>**一.文件上传**\r\n\r\n\r\n----------\r\n\r\n\r\n1.引入依赖包\r\n-------\r\n文件上传需要额外引入包分别是\r\n\r\n 1. commons-fileupload-1.3.1.jar\r\n 2. commons-io-2.4.jar\r\n\r\n2.配置jsp页面\r\n---------\r\n\r\n```\r\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\r\n<%@taglib prefix=\"sf\" uri=\"http://www.springframework.org/tags/form\" %>\r\n<html>\r\n<head>\r\n    <meta charset=\"utf-8\">\r\n    <title>用户登录</title>\r\n</head>\r\n<body>\r\n	<%--文件上传的话需要enctype=\"multipart/form-data\"--%>\r\n    <sf:form modelAttribute=\"user\" method=\"post\" enctype=\"multipart/form-data\">\r\n        用户名:<sf:input path=\"username\"/><sf:errors path=\"username\"/>\r\n        <br>\r\n        密码:<sf:input path=\"password\"/><sf:errors path=\"password\"/>\r\n        <br>\r\n        昵称:<sf:input path=\"nickname\"/><sf:errors path=\"nickname\"/>\r\n        <br>\r\n        <%--这里设置文件上传--%>\r\n        文件:<input type=\"file\" name=\"file\">\r\n        <input type=\"submit\" value=\"提交\">\r\n    </sf:form>\r\n</body>\r\n</html>\r\n```\r\n\r\n3.配置相应的控制器\r\n----------\r\n\r\n```java\r\n@RequestMapping(value = \"/login\",method = RequestMethod.POST)\r\n    public String login(@Validated User user, BindingResult br, Model model,@RequestParam(\"file\") MultipartFile file){\r\n        if (br.hasErrors()){\r\n            return \"user/login\";\r\n        }\r\n        //分别获取的是变量名file---文件类型---文件名\r\n        System.out.println(file.getName()+\"---\"+file.getContentType()+\"---\"+file.getOriginalFilename());\r\n        try {\r\n            if (!file.isEmpty()){\r\n            //使用StreamsAPI方式拷贝文件\r\n                Streams.copy(file.getInputStream(),new FileOutputStream(\"E:/temp/\"+file.getOriginalFilename()),true);\r\n            }\r\n        } catch (IOException e) {\r\n            System.out.println(\"文件上传失败\");\r\n            e.printStackTrace();\r\n        }\r\n        System.out.println(user.toString());\r\n        return \"user/login\";\r\n    }\r\n```\r\n至此单个文件上传完成.\r\n\r\n4.多文件上传\r\n-------\r\n\r\n多文件上传很简单,只需要把参数改为数组就可以了\r\n```java\r\n    @RequestMapping(value = \"/login\",method = RequestMethod.POST)\r\n    public String login(@Validated User user, BindingResult br, Model model,@RequestParam(\"file\") MultipartFile[] file){\r\n        if (br.hasErrors()){\r\n            return \"user/login\";\r\n        }\r\n        //这里对文件进行遍历\r\n        for (MultipartFile mul:file){\r\n        //分别获取的是变量名file---文件类型---文件名\r\n            System.out.println(mul.getName()+\"---\"+mul.getContentType()+\"---\"+mul.getOriginalFilename());\r\n            try {\r\n                if (!mul.isEmpty()){\r\n                    Streams.copy(mul.getInputStream(),new FileOutputStream(\"E:/temp/\"+mul.getOriginalFilename()),true);\r\n                }\r\n            } catch (IOException e) {\r\n                System.out.println(\"文件上传失败\");\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n        System.out.println(user.toString());\r\n        return \"user/login\";\r\n    }\r\n```\r\n\r\n\r\n----------\r\n<h1>**二.文件下载**\r\n\r\n\r\n----------\r\n下载需要把文件转换成二进制流,然后让客户端读取这个二进制流写入到本机,这样就实现了下载功能.那么现在就要想两个问题:1.怎么把文件写成二进制流?  2.怎么把让客户端相应,开始下载?\r\n\r\n答案;\r\n\r\n1. 写成二进制流可以用之前导入的上传组件提供的方法:`FileUtils.readFileToByteArray(file)`\r\n2. 让浏览器相应,则需要设置相应的**httpHeader**了,并且利用spring提供的ResponseEntity把返回值设置为header和响应内容\r\n\r\n1.创建控制器代码\r\n---------\r\n\r\n```\r\n            @RequestMapping(value = \"/download\")\r\n            public ResponseEntity<byte[]> download() throws IOException {\r\n//                指定文件,必须是绝对路径\r\n            File file = new File(\"E:/temp/me-bg.jpg\");\r\n//                下载浏览器响应的那个文件名\r\n            String dfileName = \"1.jpg\";\r\n//                下面开始设置HttpHeaders,使得浏览器响应下载\r\n            HttpHeaders headers = new HttpHeaders();\r\n//                设置响应方式\r\n            headers.setContentType(MediaType.APPLICATION_OCTET_STREAM);\r\n//                设置响应文件\r\n            headers.setContentDispositionFormData(\"attachment\", dfileName);\r\n//                把文件以二进制形式写回\r\n            return new ResponseEntity<byte[]>(FileUtils.readFileToByteArray(file), headers, HttpStatus.CREATED);\r\n        }\r\n```\r\n\r\n2.测试下载\r\n------\r\n\r\n访问指定的控制器就能触发下载了\r\n\r\n![这里写图片描述](http://img.blog.csdn.net/20160405143238952)\r\n\r\n','SpringMVC',1,0,9,0,1,'2016-10-05 11:43:26','2016-10-05 11:43:28',1,NULL,NULL),
	(5,'SpringMVC学习记录(五)--表单标签',1,'在使用SpringMVC的时候我们可以使用Spring封装的一系列表单标签，这些标签都可以访问到ModelMap中的内容。下面将对这些标签一一介绍。1.引入标签头文件在正式介绍SpringMVC的表单标签之前，我们需要先在JSP中声明使用的标签，具体做法是在JSP文件的顶部加入以下指令：<%@taglib prefix=\"sf\" uri=\"http://www.springframework.org...','    <h1>该文章过长未修复有问题</h1>','\r\n\r\n在使用SpringMVC的时候我们可以使用Spring封装的一系列表单标签，这些标签都可以访问到ModelMap中的内容。下面将对这些标签一一介绍。\r\n\r\n\r\n----------\r\n\r\n1.引入标签头文件\r\n---------\r\n在正式介绍SpringMVC的表单标签之前，我们需要先在JSP中声明使用的标签，具体做法是在JSP文件的顶部加入以下指令：\r\n```\r\n<%@taglib prefix=\"sf\" uri=\"http://www.springframework.org/tags/form\" %>\r\n```\r\n\r\n\r\n----------\r\n\r\n2.form标签\r\n--------\r\n使用Spring的form标签主要有两个作用，第一是它会自动的绑定来自Model中的一个属性值到当前form对应的实体对象，默认是command属性(一般都用modelAttribute,两者本质上没有区别)，这样我们就可以在form表单体里面方便的使用该对象的属性了；第二是它支持我们在提交表单的时候使用除GET和POST之外的其他方法进行提交，包括DELETE和PUT等。\r\n\r\n - 代码实例\r\n```jsp\r\n        // 这里使用modelAttribute换成commandName也是一样的效果\r\n <sf:form action=\"formTag/form.do\" method=\"post\" modelAttribute=\"user\">\r\n    <table>\r\n        <tr>\r\n            <td>Name:</td><td><form:input path=\"name\"/></td>\r\n        </tr>\r\n        <tr>\r\n            <td>Age:</td><td><form:input path=\"age\"/></td>\r\n        </tr>\r\n        <tr>\r\n            <td colspan=\"2\"><input type=\"submit\" value=\"提交\"/></td>\r\n        </tr>\r\n    </table>\r\n</sf:form>\r\n```\r\n\r\n这个时候如果Model中存在一个属性名称为user的javaBean，而且该javaBean拥有属性name和age的时候，在渲染上面的代码时就会取command的对应属性值赋给对应标签的值。如在上面的代码中，假设Model中存在一个属性名称为user的javaBean，且它的name和age属性分别为“Zhangsan”和“36”时，那么它在渲染时就会生成如下一段代码：\r\n```jsp\r\n<form id=\"user\" action=\"formTag/form.do\" method=\"post\">\r\n    <table>\r\n        <tr>\r\n            <td>Name:</td><td><input id=\"name\" name=\"name\" type=\"text\" value=\"ZhangSan\"/></td>\r\n        </tr>\r\n        <tr>\r\n            <td>Age:</td><td><input id=\"age\" name=\"age\" type=\"text\" value=\"36\"/></td>\r\n        </tr>\r\n        <tr>\r\n            <td colspan=\"2\"><input type=\"submit\" value=\"提交\"/></td>\r\n        </tr>\r\n    </table>\r\n</form>\r\n```\r\n从上面生成的代码中，我们可以看出，当没有指定form标签的id时它会自动获取该form标签绑定的Model中对应属性名称作为id，而对于input标签在没有指定id的情况下它会自动获取path指定的属性作为id和name。\r\n###2.支持隐藏域请求\r\n看下面代码,我们可以把form的method设为delete\r\n```\r\n<form:form action=\"formTag/form.do\" method=\"delete\" modelAttribute=\"user\">\r\n    <table>\r\n        <tr>\r\n            <td>Name:</td><td><form:input path=\"name\"/></td>\r\n        </tr>\r\n        <tr>\r\n            <td>Age:</td><td><form:input path=\"age\"/></td>\r\n        </tr>\r\n        <tr>\r\n            <td colspan=\"2\"><input type=\"submit\" value=\"提交\"/></td>\r\n        </tr>\r\n    </table>\r\n</form:form>\r\n```\r\n在上面代码中我们设定了该form的提交方法是delete，这样在后台我们就可以给对应的请求方法的RequestMapping加上method为RequestMethod.DELETE的限制。我们来看一下上面的代码在进行渲染的时候会生成怎样的Html代码，其生成的代码如下所示：\r\n```\r\n<form id=\"user\" action=\"formTag/form.do\" method=\"post\">\r\n    <input type=\"hidden\" name=\"_method\" value=\"delete\"/>\r\n    <table>\r\n        <tr>\r\n            <td>Name:</td><td><input id=\"name\" name=\"name\" type=\"text\" value=\"ZhangSan\"/></td>\r\n        </tr>\r\n        <tr>\r\n            <td>Age:</td><td><input id=\"age\" name=\"age\" type=\"text\" value=\"36\"/></td>\r\n        </tr>\r\n        <tr>\r\n            <td colspan=\"2\"><input type=\"submit\" value=\"提交\"/></td>\r\n        </tr>\r\n    </table>\r\n</form>\r\n```\r\n从它生成的代码我们可以看出，Spring在实现除GET和POST之外的请求方法时，还是使用的POST方法进行请求，然后给表单加上了一个隐藏域，用以表示真正的请求方法，这个隐藏域的名称默认是“_method”。上面这样定义之后是不是就意味着我们可以以delete方式访问到“formTag/form.do”了呢？答案是不行的。这样定义我们只是多加了一个用以表示请求方法的隐藏域而已，实际的请求方式还是POST。Spring为我们提供了一个Filter——HiddenHttpMethodFilter，通过这个Filter我们可以把以POST方式传递过来的表示实际请求方式的参数转换为对应的真正的Http请求方法。所以这个时候我们还需要在**web.xml**中加上如下代码：\r\n```\r\n    <filter>\r\n       <filter-name>hiddenHttpMethodFilter</filter-name>\r\n       <filter-class>org.springframework.web.filter.HiddenHttpMethodFilter</filter-class>\r\n    </filter>\r\n    <filter-mapping>\r\n       <filter-name>hiddenHttpMethodFilter</filter-name>\r\n       <url-pattern>/*</url-pattern>\r\n    </filter-mapping>\r\n```\r\n注意：HiddenHttpMethodFilter只能对以POST方式进行传递的表示请求方式的隐藏域转换为真正的Http请求方式。当我们直接在form：form标签的method中使用除GET和POST方法以外的其他方法时，Spring会自动生成以POST方式进行传递的表单以及对应的隐藏域。所以当我们需要手动的设置表示请求方法的隐藏域时，我们就需要指定表单的请求方式为POST，为GET将不会生效。\r\n```\r\n<form:form action=\"formTag/form.do\" method=\"post\" modelAttribute=\"user\">\r\n    <input type=\"hidden\" name=\"_method\" value=\"head\"/>\r\n    <table>\r\n        <tr>\r\n            <td>Name:</td><td><form:input path=\"name\"/></td>\r\n        </tr>\r\n        <tr>\r\n            <td>Age:</td><td><form:input path=\"age\"/></td>\r\n        </tr>\r\n        <tr>\r\n            <td colspan=\"2\"><input type=\"submit\" value=\"提交\"/></td>\r\n        </tr>\r\n    </table>\r\n</form:form>\r\n```\r\n上面代码就是一个手动定义请求方式的隐藏域的示例。这里表示请求方式的隐藏域的名称默认是“_method”，如果不想使用这个默认值的话，我们也可以通过form:form标签的methodParam属性来指定。如下面这个示例：\r\n```\r\n<form:form action=\"formTag/form.do\" method=\"post\" methodParam=\"requestMethod\" modelAttribute=\"user\">\r\n    <input type=\"hidden\" name=\"requestMethod\" value=\"head\"/>\r\n    <table>\r\n        <tr>\r\n            <td>Name:</td><td><form:input path=\"name\"/></td>\r\n        </tr>\r\n        <tr>\r\n            <td>Age:</td><td><form:input path=\"age\"/></td>\r\n        </tr>\r\n        <tr>\r\n            <td colspan=\"2\"><input type=\"submit\" value=\"提交\"/></td>\r\n        </tr>\r\n    </table>\r\n</form:form>\r\n```\r\n同时我们也要告诉HiddenHttpMethodFilter我们是使用哪个表单参数作为methodParam，所以我们需要在配置HiddenHttpMethodFilter的时候指明methodParam对应的值。\r\n```\r\n    <filter>\r\n       <filter-name>hiddenHttpMethodFilter</filter-name>\r\n       <filter-class>org.springframework.web.filter.HiddenHttpMethodFilter</filter-class>\r\n       <init-param>\r\n           <param-name>methodParam</param-name>\r\n           <param-value>requestMethod</param-value>\r\n       </init-param>\r\n    </filter>\r\n    <filter-mapping>\r\n       <filter-name>hiddenHttpMethodFilter</filter-name>\r\n       <url-pattern>/*</url-pattern>\r\n    </filter-mapping>\r\n```\r\n另外需要注意的是在有Multipart请求处理的时候HiddenHttpMethodFilter需要在Multipart处理之后执行，因为在处理Multipart时需要从POST请求体中获取参数。所以我们通常会在HiddenHttpMethodFilter之前设立一个MultipartFilter。MultipartFilter默认会去寻找一个名称为filterMultipartResolver的MultipartResolver bean对象来对当前的请求进行封装。所以当你定义的MultipartResolver的名称不为filterMultipartResolver的时候就需要在定义MultipartFilter的时候通过参数multipartResolverBeanName来指定。\r\n```\r\n    <filter>\r\n       <filter-name>multipartFilter</filter-name>\r\n       <filter-class>org.springframework.web.multipart.support.MultipartFilter</filter-class>\r\n       <init-param>\r\n           <param-name>multipartResolverBeanName</param-name>\r\n           <param-value>multipartResolver</param-value>\r\n       </init-param>\r\n    </filter>\r\n    <filter-mapping>\r\n       <filter-name>multipartFilter</filter-name>\r\n       <url-pattern>/*</url-pattern>\r\n    </filter-mapping>\r\n   \r\n    <filter>\r\n       <filter-name>hiddenHttpMethodFilter</filter-name>\r\n       <filter-class>org.springframework.web.filter.HiddenHttpMethodFilter</filter-class>\r\n       <init-param>\r\n           <param-name>methodParam</param-name>\r\n           <param-value>requestMethod</param-value>\r\n       </init-param>\r\n    </filter>\r\n    <filter-mapping>\r\n       <filter-name>hiddenHttpMethodFilter</filter-name>\r\n       <url-pattern>/*</url-pattern>\r\n    </filter-mapping>\r\n```\r\n\r\n\r\n----------\r\n\r\n2.input标签\r\n---------\r\nSpringMVC的input标签会被渲染为一个type为text的普通Html input标签。使用SpringMVC的input标签的唯一作用就是它能绑定表单数据。SpringMVC表单标签最大的好处就是它支持数据绑定，当我们的表单标签不需要绑定的数据的时候，我们应该使用普通的Html标签。关于input标签绑定表单数据的方法已经在介绍form标签的时候顺带介绍过了，这里就不再过多的赘述了。\r\n```\r\n<form:form action=\"formTag/form.do\" method=\"head\" modelAttribute=\"user\" methodParam=\"requestMethod\">\r\n    <table>\r\n        <tr>\r\n            <td>Name:</td><td><form:input path=\"name\"/></td>\r\n        </tr>\r\n        <tr>\r\n            <td>Age:</td><td><form:input path=\"age\"/></td>\r\n        </tr>\r\n        <tr>\r\n            <td colspan=\"2\"><input type=\"submit\" value=\"提交\"/></td>\r\n        </tr>\r\n    </table>\r\n</form:form>\r\n```\r\n\r\n\r\n----------\r\n\r\n3.hidden标签\r\n----------\r\nhidden标签会被渲染为一个type为hidden的普通Html input标签。用法跟input标签一样，也能绑定表单数据，只是它生成的是一个隐藏域。\r\n\r\n\r\n----------\r\n\r\n4.checkbox标签\r\n------------\r\ncheckbox标签会被渲染为一个type为checkbox的普通HTML input标签。checkbox标签也是支持绑定数据的。我们知道checkbox就是一个复选框，有选中和不选中两种状态，那么我们在使用checkbox标签的时候是如何来设定它的状态的呢？checkbox标签的选中与否状态是根据它绑定的值来判断的\r\n\r\n- 绑定boolean数据\r\n```\r\n<form:form action=\"formTag/form.do\" method=\"post\" commandName=\"user\">\r\n    <table>\r\n        <tr>\r\n            <td>Male:</td><td><form:checkbox path=\"male\"/></td>\r\n        </tr>\r\n        <tr>\r\n            <td colspan=\"2\"><input type=\"submit\" value=\"提交\"/></td>\r\n        </tr>\r\n    </table>\r\n</form:form>\r\n```\r\n 看上面这段代码，这个时候假设我们在渲染该视图之前往ModelMap中添加了一个user属性，并且该user对象有一个类型为boolean的属性male，那么这个时候如果male属性为true则Male那一栏的复选框将会被选中。\r\n \r\n- 绑定列表数据\r\n这里的列表数据包括数组、List和Set。下面将以List为例讲一下checkbox是如何根据绑定的列表数据来设定选中状态的。现在假设有一个类User，其有一个类型为List的属性roles，如下所示：\r\n```\r\npublic class User {\r\n \r\n    private List<String> roles;\r\n \r\n    public List<String> getRoles() {\r\n       return roles;\r\n    }\r\n \r\n    public void setRoles(List<String> roles) {\r\n       this.roles = roles;\r\n    }\r\n}\r\n```\r\n那么当我们需要展现该User是否拥有某一个Role的时候，我们可以使用checkbox标签来绑定roles数据进行展现。当checkbox标签的value在我们绑定的列表数据中存在的时候该checkbox将为选中状态。来看下面一段代码：\r\n```\r\n<form:form action=\"formTag/form.do\" method=\"post\" commandName=\"user\">\r\n    <table>\r\n        <tr>\r\n            <td>Roles:</td>\r\n            <td>\r\n               <form:checkbox path=\"roles\" value=\"role1\"/>Role1<br/>\r\n               <form:checkbox path=\"roles\" value=\"role2\"/>Role2<br/>\r\n               <form:checkbox path=\"roles\" value=\"role3\"/>Role3\r\n            </td>\r\n        </tr>\r\n    </table>\r\n</form:form>\r\n```\r\n就上面代码而言就是当User拥有role1的时候对应的<form:checkbox path=\"roles\" value=\"role1\"/>就会为选中状态，也就是说roles列表中包含role1的时候该checkbox就会为选中状态。\r\n\r\n- 绑定一个Object数据\r\ncheckbox还支持绑定数据类型为Object的数据，这种情况下Spring会拿所绑定对象数据的toString结果跟当前checkbox的value进行比较，如果能够进行匹配则该checkbox将为选中状态。\r\n\r\n\r\n----------\r\n\r\n5.Checkboxes标签\r\n--------------\r\n相对于一个checkbox标签只能生成一个对应的复选框而言，一个checkboxes标签将根据其绑定的数据生成N个复选框。checkboxes绑定的数据可以是数组、集合和Map。在使用checkboxes时我们有两个属性是必须指定的，一个是path，另一个是items。Items表示当前要用来展现的项有哪些，而path所绑定的表单对象的属性表示当前表单对象拥有的项，即在items所展现的所有项中表单对象拥有的项会被设定为选中状态。先来看以下一段代码：\r\n```\r\n<form:form action=\"formTag/form.do\" method=\"post\" commandName=\"user\">\r\n    <table>\r\n        <tr>\r\n           <td>Roles:</td>\r\n            <td>\r\n               <form:checkboxes path=\"roles\" items=\"${roleList}\"/> \r\n            </td>\r\n        </tr>\r\n        <tr>\r\n            <td colspan=\"2\"><input type=\"submit\" value=\"提交\"/></td>\r\n        </tr>\r\n    </table>\r\n</form:form>\r\n```\r\n上面的JSP视图对应着如下的处理器方法：\r\n```\r\n    @RequestMapping(value=\"form\", method=RequestMethod.GET)\r\n    public String formTag(Map<String, Object> map) {\r\n       User user = new User();\r\n       List<String> roles = new ArrayList<String>();\r\n       roles.add(\"role1\");\r\n       roles.add(\"role3\");\r\n       user.setRoles(roles);\r\n       List<String> roleList = new ArrayList<String>();\r\n       roleList.add(\"role1\");\r\n       roleList.add(\"role2\");\r\n       roleList.add(\"role3\");\r\n       map.put(\"user\", user);\r\n       map.put(\"roleList\", roleList);\r\n       return \"formTag/form\";\r\n    }\r\n```\r\n从以上代码中我们可以看到我们放在ModelMap中的roleList对象有三个元素，分别是role1、role2和role3，而我们的表单对象User的roles属性只拥有两个元素，分别是role1和role3,，所以当我们访问该处理器方法返回如上所示的视图页面时，我们要展现的复选框项是roleList，也就是role1、role2和role3，而我们表单对象只拥有role1和role3，所以在页面进行渲染的时候会展示3个复选框项，但只有role1和role3会被设定为选中状态。\r\n\r\n\r\n----------\r\n\r\n\r\n上面介绍的这种情况是使用List作为展现复选框项的数据源，这种情况我们已经看到了它所呈现出来的标签Label和它的值是一样的。使用Array和Set作为数据源也是这种情况。那么如果要让checkboxes呈现出来的Label和实际上送的value不同的话应该怎么做呢？这个时候我们就可以使用Map作为数据源了。使用Map作为checkboxes的items属性的数据源时Key将作为真正的复选框的value，而Map的value将作为Label进行展示。当使用Map作为checkboxes的items属性的数据源时我们绑定的表单对象属性的类型可以是Array、集合和Map，这种情况就是判断items Map中是否含有对应的key来决定当前的复选框是否处于选中状态。我们来看以下一个处理器方法以及其对应的视图代码。\r\n```\r\n    @RequestMapping(value=\"form\", method=RequestMethod.GET)\r\n    public String formTag(Map<String, Object> map) {\r\n       User user = new User();\r\n       List<String> roles = new ArrayList<String>();\r\n       roles.add(\"role1\");\r\n       roles.add(\"role3\");\r\n       user.setRoles(roles);\r\n       Map<String, String> roleMap = new HashMap<String, String>();\r\n       roleMap.put(\"role1\", \"角色1\");\r\n       roleMap.put(\"role2\", \"角色2\");\r\n       roleMap.put(\"role3\", \"角色3\");\r\n       map.put(\"user\", user);\r\n       map.put(\"roleMap\", roleMap);\r\n       return \"formTag/form\";\r\n    }\r\n```\r\n对应的视图代码：\r\n```\r\n<form:form action=\"formTag/form.do\" method=\"post\" commandName=\"user\">\r\n    <table>\r\n        <tr>\r\n            <td>Roles:</td>\r\n            <td>\r\n               <form:checkboxes path=\"roles\" items=\"${roleMap}\"/>  \r\n            </td>\r\n        </tr>\r\n        <tr>\r\n            <td colspan=\"2\"><input type=\"submit\" value=\"提交\"/></td>\r\n        </tr>\r\n    </table>\r\n</form:form>\r\n```\r\n  这个时候我们知道会呈现出3个复选框，而checkboxes绑定的表单对象user的roles属性是一个集合对象，其包含的两个元素都能在checkboxes的items数据源中找到对应的Key，所以以这两个元素为value的checkbox将处于选中状态\r\n  \r\n  当我们使用Array或者集合作为数据源，且里面的元素都是一个一个POJO时，我们还可以使用checkboxes标签的itemLabel和itemValue属性来表示使用数组或者集合中元素对象的哪一个属性作为需要呈现的单选框的label和value。\r\n\r\n\r\n----------\r\n\r\n6.radiobutton标签\r\n---------------\r\nradiobutton标签会被渲染为一个type为radio的普通HTML input标签。radiobutton标签也是可以绑定数据的。以下是一个radiobutton的简单应用示例：\r\n```\r\n<form:form action=\"formTag/form.do\" method=\"post\" commandName=\"user\">\r\n    <table>\r\n        <tr>\r\n            <td>性别:</td>\r\n            <td>\r\n               <form:radiobutton path=\"sex\" value=\"1\"/>男\r\n               <form:radiobutton path=\"sex\" value=\"0\"/>女\r\n            </td>\r\n        </tr>\r\n        <tr>\r\n            <td colspan=\"2\"><input type=\"submit\" value=\"提交\"/></td>\r\n        </tr>\r\n    </table>\r\n</form:form>\r\n```\r\n 在上面代码中我们的radiobutton标签都是绑定了表单对象user的sex属性，当sex为1的时候就代表性别为男，上面性别为男的那一行就会被选中，当sex为0的时候就代表性别为女，上面性别为女的那一行就会被选中。\r\n\r\n\r\n----------\r\n\r\n7.radiobuttons标签\r\n----------------\r\nradiobuttons标签跟radiobutton标签的区别如同checkbox标签对checkboxes标签的区别。使用radiobuttons标签的时候将生成多个单选按钮。使用radiobuttons有两个属性也是我们必须指定的，一个是path属性，表示绑定的表单对象对应的属性，另一个是items属性，表示用于生成单选按钮的数据源。跟checkboxes一样，radiobuttons的items属性和path属性都可以是Array、集合或者是Map。现在我们假设user在篮球、足球、乒乓球、羽毛球和排球这5种运动中选择一种作为自己最喜欢的球类运动。处理器方法和返回的对应的视图代码如下：\r\n```\r\n    @RequestMapping(value=\"form\", method=RequestMethod.GET)\r\n    public String formTag(Map<String, Object> map) {\r\n       User user = new User();\r\n       user.setFavoriteBall(4);//设置我最喜爱的球类运动是4羽毛球\r\n       Map<Integer, String> ballMap = new HashMap<Integer, String>();\r\n       ballMap.put(1, \"篮球\");\r\n       ballMap.put(2, \"足球\");\r\n       ballMap.put(3, \"乒乓球\");\r\n       ballMap.put(4, \"羽毛球\");\r\n       ballMap.put(5, \"排球\");\r\n       map.put(\"user\", user);\r\n       map.put(\"ballMap\", ballMap);\r\n       return \"formTag/form\";\r\n    }\r\n```\r\nJSP视图\r\n```\r\n<form:form action=\"formTag/form.do\" method=\"post\" commandName=\"user\">\r\n    <table>\r\n        <tr>\r\n            <td>最喜欢的球类:</td>\r\n            <td>\r\n               <form:radiobuttons path=\"favoriteBall\" items=\"${ballMap}\" delimiter=\"&nbsp;\"/>\r\n            </td>\r\n        </tr>\r\n        <tr>\r\n            <td colspan=\"2\"><input type=\"submit\" value=\"提交\"/></td>\r\n        </tr>\r\n    </table>\r\n</form:form>\r\n```\r\n   在上述代码中我们可以看到我们使用了radiobuttons的delimiter属性，该属性表示进行展示的radiobutton之间的分隔符。这里用的是一个空格。结果页面如下所示：\r\n   \r\n\r\n\r\n----------\r\n\r\n8.password标签\r\n------------\r\npassword标签将会被渲染为一个type为password的普通HTML input标签。\r\n\r\n\r\n----------\r\n\r\n9.select标签\r\n----------\r\nselect标签将会被渲染为一个普通的HTML select标签。这里还拿前面的user最喜欢的球类运动来做示例，有如下这样一个处理器方法和对应的视图页面：\r\n```\r\n    @RequestMapping(value=\"form\", method=RequestMethod.GET)\r\n    public String formTag(Map<String, Object> map) {\r\n       User user = new User();\r\n       user.setFavoriteBall(4);//设置我最喜爱的球类运动是4羽毛球\r\n       Map<Integer, String> ballMap = new HashMap<Integer, String>();\r\n       ballMap.put(1, \"篮球\");\r\n       ballMap.put(2, \"足球\");\r\n       ballMap.put(3, \"乒乓球\");\r\n       ballMap.put(4, \"羽毛球\");\r\n       ballMap.put(5, \"排球\");\r\n       map.put(\"user\", user);\r\n       map.put(\"ballMap\", ballMap);\r\n       return \"formTag/form\";\r\n    }\r\n```\r\nJSP视图\r\n```\r\n<form:form action=\"formTag/form.do\" method=\"post\" commandName=\"user\">\r\n    <table>\r\n        <tr>\r\n            <td>最喜欢的运动:</td>\r\n            <td>\r\n               <form:select path=\"favoriteBall\" items=\"${ballMap}\"/>\r\n            </td>\r\n        </tr>\r\n       <tr>\r\n            <td colspan=\"2\"><input type=\"submit\" value=\"提交\"/></td>\r\n        </tr>\r\n    </table>\r\n</form:form>\r\n```\r\n从上面示例我们可以看出，我们通过items属性给select标签指定了一个数据源，并且绑定了表单对象user的favoriteBall属性。Items属性是用于指定当前select的所有可选项的，但是它对于select标签而言不是必须的，因为我们还可以手动的在select标签中间加上option标签来指定select可选的option。Select标签支持的items属性的数据类型可以是Array、Collection和Map，当数据类型为Array或Collection时且其中的元素为一个POJO时，我们可以通过属性itemLabel和itemValue来指定将用于呈现的option Label和Value，其他情况下Array和Collection数据源中的元素将既作为可选项option的value又作为它的Label。当items的数据类型为Map时，Map的key将作为可选项option的value，而Map的value将作为option的Label标签。\r\n\r\n\r\n----------\r\n\r\n10.option标签\r\n-----------\r\noption标签会被渲染为一个普通的HTML option标签。当一个SpringMVC select标签没有通过items属性指定自己的数据源的时候，我们就可以在select标签中通过普通HTML option标签或者SpringMVC option标签来指定可以选择的项。\r\n```\r\n<form:form action=\"formTag/form.do\" method=\"post\" commandName=\"user\">\r\n    <table>\r\n        <tr>\r\n            <td>最喜欢的运动:</td>\r\n            <td>\r\n               <form:select path=\"favoriteBall\">\r\n                   <option>请选择</option>\r\n                   <form:option value=\"1\">篮球</form:option>\r\n                   <option value=\"4\">羽毛球</option>\r\n               </form:select>\r\n            </td>\r\n        </tr>\r\n       <tr>\r\n            <td colspan=\"2\"><input type=\"submit\" value=\"提交\"/></td>\r\n        </tr>\r\n    </table>\r\n</form:form>\r\n```\r\n我们可以看到在上面代码中我们是没有指定select标签的数据源的，而是通过在select标签体里面指定普通HTML option标签和SpringMVC option标签来指定可选项。\r\n\r\n\r\n----------\r\n\r\n11.textarea标签\r\n-------------\r\nSpringMVC textarea标签将被渲染为普通HTML textarea标签。简单示例如下：\r\n```\r\n<form:form action=\"formTag/form.do\" method=\"post\" commandName=\"user\">\r\n    <table>\r\n        <tr>\r\n            <td>自我介绍:</td>\r\n            <td>\r\n               <form:textarea path=\"introduction\" cols=\"20\" rows=\"10\"/>\r\n            </td>\r\n        </tr>\r\n       <tr>\r\n            <td colspan=\"2\"><input type=\"submit\" value=\"提交\"/></td>\r\n        </tr>\r\n    </table>\r\n</form:form>\r\n```\r\n\r\n\r\n----------\r\n\r\n\r\n12.errors标签\r\n-----------\r\nSpringMVC errors标签是对应于SpringMVC的Errors对象的。它的作用就是用于展现Errors对象中包含的错误信息的。我们利用errors标签来展现Errors的时候是通过errors标签的path属性来绑定一个错误信息的。我们可以通过path属性来展现两种类型的错误信息。\r\nl  所有的错误信息，这个时候path的值应该置为“*”\r\nl  当前对象的某一个域的错误信息，这个时候path的值应为所需展现的域的名称\r\n看下面这样一个例子：\r\n定义了一个UserValidator对象，专门用来对User对象进行验证，其代码如下：\r\n```\r\nimport org.springframework.validation.Errors;\r\nimport org.springframework.validation.ValidationUtils;\r\nimport org.springframework.validation.Validator;\r\n \r\npublic class UserValidator implements Validator {\r\n \r\n    @Override\r\n    public boolean supports(Class<?> clazz) {\r\n       // TODO Auto-generated method stub\r\n       return User.class.equals(clazz);\r\n    }\r\n \r\n    @Override\r\n    public void validate(Object target, Errors errors) {\r\n       // TODO Auto-generated method stub\r\n       ValidationUtils.rejectIfEmpty(errors, \"name\", null, \"Name Is Empty\");\r\n       ValidationUtils.rejectIfEmpty(errors, \"username\", null, \"Username Is Empty.\");\r\n    }\r\n \r\n}\r\n```\r\n 然后我们有这样一个控制器类：\r\n```\r\n @Controller\r\n@RequestMapping(\"formTag\")\r\npublic class FormTagController {\r\n \r\n    @RequestMapping(value=\"form\", method=RequestMethod.GET)\r\n    public String formTag(Map<String, Object> map) {\r\n       User user = new User();\r\n       map.put(\"user\", user);\r\n       return \"formTag/form\";\r\n    }\r\n   \r\n    @InitBinder\r\n    public void initBinder(DataBinder binder) {\r\n       binder.setValidator(new UserValidator());\r\n    }\r\n   \r\n    @RequestMapping(value=\"form\", method=RequestMethod.POST)\r\n    public String form(@Valid User user, Errors errors) {\r\n       if (errors.hasFieldErrors())\r\n           return \"formTag/form\";\r\n       return \"formTag/submit\";\r\n    }\r\n}\r\n```\r\n  我们可以看到我们在上述控制器类中通过DataBinder对象给该类设定了一个用于验证的UserValidator，这样当我们请求该控制器的时候UserValidator将生效。\r\n  \r\n   我们有如下这样一段表单代码：\r\n```\r\n<form:form action=\"formTag/form.do\" method=\"post\" commandName=\"user\">\r\n    <table border=\"1px\" bordercolor=\"blue\">\r\n        <tr align=\"center\">\r\n            <td width=\"100\">姓名:</td>\r\n            <td width=\"150\"><form:input path=\"name\"/></td>\r\n        </tr>\r\n        <tr align=\"center\">\r\n            <td>用户名:</td>\r\n            <td><form:input path=\"username\"/></td>\r\n        </tr>\r\n        <tr>\r\n            <td>所有错误信息:</td>\r\n            <td><form:errors path=\"*\"/></td>\r\n        </tr>\r\n        <tr>\r\n            <td>Name的错误信息:</td>\r\n            <td><form:errors path=\"name\"/></td>\r\n        </tr>\r\n        <tr align=\"center\">\r\n            <td colspan=\"2\"><input type=\"submit\" value=\"提交\"/></td>\r\n        </tr>\r\n    </table>\r\n</form:form>\r\n```\r\n  当我们提交上面的表单的时候会往Errors中注入两个错误信息\r\n  \r\n','SpringMVC',0,0,9,0,1,'2016-10-05 11:44:15','2016-10-05 11:44:17',1,NULL,NULL),
	(6,'SpringMVC学习记录(六)--Validator验证',1,'SpringMVC服务器验证一种是有两种方式,一种是基于Validator接口,一种是使用Annotaion JSR-303标准的验证,下面主要是学习这两种,工作中推荐后者,方便很多一.基于Validator接口的验证.首先创建User实例,并加入几个属性public class User { private String username; private String passw...','    <h1>该文章过长未修复有问题</h1>','\r\n\r\nSpringMVC服务器验证一种是有两种方式,一种是基于Validator接口,一种是使用Annotaion JSR-303标准的验证,下面主要是学习这两种,工作中推荐后者,方便很多\r\n\r\n\r\n----------\r\n\r\n一.基于Validator接口的验证.\r\n-------------------\r\n首先创建User实例,并加入几个属性\r\n```\r\npublic class User {\r\n    private String username;\r\n    private String password;\r\n    private String nickname;\r\n\r\n    public String getUsername() {\r\n        return username;\r\n    }\r\n\r\n    public void setUsername(String username) {\r\n        this.username = username;\r\n    }\r\n\r\n    public String getPassword() {\r\n        return password;\r\n    }\r\n\r\n    public void setPassword(String password) {\r\n        this.password = password;\r\n    }\r\n\r\n    public String getNickname() {\r\n        return nickname;\r\n    }\r\n\r\n    public void setNickname(String nickname) {\r\n        this.nickname = nickname;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"username--\"+username+\"password--\"+password+\"nickname--\"+nickname;\r\n    }\r\n}\r\n```\r\n\r\n接着创建用于校检的类UserValidator,让其实现Validator,覆盖其中的两个方法\r\n```\r\nimport main.java.model.User;\r\nimport org.springframework.validation.Errors;\r\nimport org.springframework.validation.Validator;\r\n\r\npublic class UserValidator implements Validator {\r\n\r\n\r\n    @Override\r\n    public boolean supports(Class<?> aClass) {\r\n        //判断是否是要校验的类,这里是User\r\n        return User.class.equals(aClass);\r\n    }\r\n\r\n    @Override\r\n    public void validate(Object o, Errors errors) {\r\n        User u = (User) o;\r\n        if (null == u.getPassword() || \"\".equals(u.getPassword())){\r\n            //此方法可以加四个参数,第一个表单域field,\r\n            //区分是哪个表单出错,第二个errorCode错误码,\r\n            //第三个制定了资源文件中占位符,第四个具体错误返回信息\r\n            //简写版可以把2,3参数去掉\r\n            errors.rejectValue(\"password\",null,null,\"password is null\");\r\n        }\r\n    }\r\n}\r\n```\r\n上面的类只实现了对密码判断是否为空,为空则注册这一错误信息,也就是\"password is null\",接下来要实现控制器,控制器要做的事情,第一是注册这个校验器,第二是实现校验.\r\n```\r\nimport main.java.model.User;\r\n......\r\n\r\n/**\r\n * 加上@Controller决定这个类是一个控制器\r\n */\r\n@Controller\r\n@RequestMapping(\"/user\")\r\npublic class HelloController {\r\n\r\n    //我们知道在Controller类中通过@InitBinder标记的方法只有在请求当前Controller的时候才会被执行\r\n    //所以在这里注册校验器\r\n    @InitBinder\r\n    public void initBainder(DataBinder binder){\r\n        binder.replaceValidators(new UserValidator());\r\n\r\n    }\r\n    //这个方法主要是跳转到登录页面\r\n    @RequestMapping(value = \"/login\",method = RequestMethod.GET)\r\n    public String login(Model model){\r\n        model.addAttribute(new User());\r\n        return \"user/login\";\r\n    }\r\n    //处理登录表单\r\n    @RequestMapping(value = \"/login\",method = RequestMethod.POST)\r\n    public String login(@Validated User user, BindingResult br){\r\n\r\n        if (br.hasErrors()){\r\n            return \"user/login\";\r\n        }\r\n        return \"--\";\r\n    }\r\n    }\r\n```\r\n上面代码可以看到@Validated User user, BindingResult br这两个参数,**@Validated**表明参数user是要校验的类,**BindingResult**是存储错误信息的类,两者必须一一对应,并且位置挨着,不能中间有其他参数,\r\n最后随便写一个jsp页面实现校检\r\n```\r\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\r\n<%@taglib prefix=\"sf\" uri=\"http://www.springframework.org/tags/form\" %>\r\n<%\r\n    request.setCharacterEncoding(\"utf-8\");\r\n%>\r\n<html>\r\n<head>\r\n    <meta charset=\"utf-8\">\r\n    <title>用户登录</title>\r\n</head>\r\n<body>\r\n    <sf:form modelAttribute=\"user\" method=\"post\">\r\n        用户名:<sf:input path=\"username\"/><sf:errors path=\"username\"/>\r\n        <br>\r\n        密码:<sf:input path=\"password\"/><sf:errors path=\"password\"/>\r\n        <br>\r\n        昵称:<sf:input path=\"nickname\"/><sf:errors path=\"nickname\"/>\r\n        <br>\r\n        <input type=\"submit\" value=\"提交\">\r\n    </sf:form>\r\n</body>\r\n</html>\r\n```\r\n![这里写图片描述](http://img.blog.csdn.net/20160406225008055)\r\n\r\n<font color=red>前面实现的是局部校验,只对当前控制器有效,如果要实现全局校验的话需要配置springMVC.xml文件</font>\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\"\r\n    xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\r\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans\r\n     http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\r\n     http://www.springframework.org/schema/context\r\n     http://www.springframework.org/schema/context/spring-context-3.0.xsd\r\n     http://www.springframework.org/schema/mvc\r\n     http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd\">\r\n    \r\n    <mvc:annotation-driven validator=\"userValidator\"/>\r\n   \r\n    <bean id=\"userValidator\" class=\"com.xxx.xxx.UserValidator\"/>\r\n \r\n    ...\r\n</beans>\r\n```\r\n\r\n----------\r\n\r\n二.使用Annotaion JSR-303标准的验证\r\n--------------------------\r\n使用这个需要导入支持JSR-303标准的包,建议使用Hibernate Validator这个包,先看这个标准的**原生标注**\r\n| 限制 | 说明   |\r\n| --------   | -----:  |\r\n| @Null     | 限制只能为null | \r\n| @NotNull        |   限制必须不为null \r\n| @AssertFalse      |    限制必须为false    |\r\n|@AssertTrue|限制必须为true\r\n|@DecimalMax(value)|限制必须为一个不大于指定值的数字\r\n|@DecimalMin(value)|限制必须为一个不小于指定值的数字\r\n|@Digits(integer,fraction)|限制必须为一个小数，且整数部分的位数不能超过integer，小数部分的位数不能超过fraction\r\n|@Future|限制必须是一个将来的日期\r\n|@Max(value)|限制必须为一个不大于指定值的数字\r\n|@Min(value)|限制必须为一个不小于指定值的数字\r\n|@Past|限制必须是一个过去的日期\r\n|@Pattern(value)|限制必须符合指定的正则表达式\r\n|@Size(max,min)|限制字符长度必须在min到max之间\r\n\r\n\r\n----------\r\n除此之外经常用的还有NotBlank,NotEmpty等\r\n要使用很简单,在需要验证的变量前面加上该Annotation即可,看下面使用后的User\r\n```\r\npublic class User {\r\n    @NotEmpty(message = \"用户名不能为空\")\r\n    private String username;\r\n    @Size(min=6 ,max= 20 ,message = \"密码长度不符合标准\")\r\n    private String password;\r\n    private String nickname;\r\n\r\n   ......\r\n}\r\n```\r\n然后再控制器里面加入验证就可以了\r\n```\r\n@Controller\r\n@RequestMapping(\"/user\")\r\npublic class HelloController {\r\n\r\n\r\n    @RequestMapping(value = \"/login\",method = RequestMethod.GET)\r\n    public String login(Model model){\r\n        model.addAttribute(new User());\r\n        return \"user/login\";\r\n    }\r\n\r\n    @RequestMapping(value = \"/login\",method = RequestMethod.POST)\r\n    public String login(@Validated User user, BindingResult br){\r\n\r\n        if (br.hasErrors()){\r\n            return \"user/login\";\r\n        }\r\n        return \"user/login\";\r\n    }\r\n    }\r\n```\r\n然后jsp页面还是之前的页面,验证效果如下,这种方法明显简单多了\r\n![这里写图片描述](http://img.blog.csdn.net/20160406231441302)\r\n\r\n\r\n----------\r\n\r\n\r\n3.定义自己的Annotation Validator\r\n---------------------------\r\n这部分直接从[大牛][1]那拷贝过来的.\r\n\r\n除了JSR-303原生支持的限制类型之外我们还可以定义自己的限制类型。定义自己的限制类型首先我们得定义一个该种限制类型的注解，而且该注解需要使用@Constraint标注。现在假设我们需要定义一个表示金额的限制类型，那么我们可以这样定义：\r\n```\r\n \r\nimport java.lang.annotation.ElementType;\r\nimport java.lang.annotation.Retention;\r\nimport java.lang.annotation.RetentionPolicy;\r\nimport java.lang.annotation.Target;\r\n \r\nimport javax.validation.Constraint;\r\nimport javax.validation.Payload;\r\n \r\nimport com.xxx.xxx.constraint.impl.MoneyValidator;\r\n \r\n@Target({ElementType.FIELD, ElementType.METHOD})\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@Constraint(validatedBy=MoneyValidator.class)\r\npublic @interface Money {\r\n   \r\n    String message() default\"不是金额形式\";\r\n   \r\n    Class<?>[] groups() default {};\r\n   \r\n    Class<? extends Payload>[] payload() default {};\r\n \r\n}\r\n```\r\n我们可以看到在上面代码中我们定义了一个Money注解，而且该注解上标注了@Constraint注解，使用@Constraint注解标注表明我们定义了一个用于限制的注解。@Constraint注解的validatedBy属性用于指定我们定义的当前限制类型需要被哪个ConstraintValidator进行校验。在上面代码中我们指定了Money限制类型的校验类是MoneyValidator。另外需要注意的是我们在定义自己的限制类型的注解时有三个属性是必须定义的，如上面代码所示的message、groups和payload属性。\r\n       在定义了限制类型Money之后，接下来就是定义我们的限制类型校验类MoneyValidator了。限制类型校验类必须实现接口javax.validation.ConstraintValidator，并实现它的initialize和isValid方法。我们先来看一下MoneyValidator的代码示例：\r\n       \r\n```\r\n \r\nimport java.util.regex.Pattern;\r\n \r\nimport javax.validation.ConstraintValidator;\r\nimport javax.validation.ConstraintValidatorContext;\r\n \r\nimport com.xxx.xxx.constraint.Money;\r\n \r\npublic class MoneyValidator implements ConstraintValidator<Money, Double> {\r\n \r\n    private String moneyReg = \"^\\\\d+(\\\\.\\\\d{1,2})?$\";//表示金额的正则表达式\r\n    private Pattern moneyPattern = Pattern.compile(moneyReg);\r\n   \r\n    public void initialize(Money money) {\r\n       // TODO Auto-generated method stub\r\n      \r\n    }\r\n \r\n    public boolean isValid(Double value, ConstraintValidatorContext arg1) {\r\n       // TODO Auto-generated method stub\r\n       if (value == null)\r\n           return true;\r\n       return moneyPattern.matcher(value.toString()).matches();\r\n    }\r\n \r\n}\r\n```\r\n从上面代码中我们可以看到ConstraintValidator是使用了泛型的。它一共需要指定两种类型，第一个类型是对应的initialize方法的参数类型，第二个类型是对应的isValid方法的第一个参数类型。从上面的两个方法我们可以看出isValid方法是用于进行校验的，有时候我们在校验的过程中是需要取当前的限制类型的属性来进行校验的，比如我们在对@Min限制类型进行校验的时候我们是需要通过其value属性获取到当前校验类型定义的最小值的，我们可以看到isValid方法无法获取到当前的限制类型Money。这个时候initialize方法的作用就出来了。我们知道initialize方法是可以获取到当前的限制类型的，所以当我们在校验某种限制类型时需要获取当前限制类型的某种属性的时候，我们可以给当前的ConstraintValidator定义对应的属性，然后在initialize方法中给该属性赋值，接下来我们就可以在isValid方法中使用其对应的属性了。针对于这种情况我们来看一个代码示例，现在假设我要定义自己的@Min限制类型和对应的MinValidator校验器，那么我可以如下定义：\r\n```\r\n@Target({ElementType.FIELD, ElementType.METHOD})\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@Constraint(validatedBy=MinValidator.class)\r\npublic @interface Min {\r\n \r\n    int value() default 0;\r\n   \r\n    String message();\r\n   \r\n    Class<?>[] groups() default {};\r\n   \r\n    Class<? extends Payload>[] payload() default {};\r\n}\r\n```\r\nMinValidator校验器\r\n```\r\npublic class MinValidator implements ConstraintValidator<Min, Integer> {\r\n \r\n    private int minValue;\r\n   \r\n    public void initialize(Min min) {\r\n       // TODO Auto-generated method stub\r\n       //把Min限制类型的属性value赋值给当前ConstraintValidator的成员变量minValue\r\n       minValue = min.value();\r\n    }\r\n \r\n    public boolean isValid(Integer value, ConstraintValidatorContext arg1) {\r\n       // TODO Auto-generated method stub\r\n       //在这里我们就可以通过当前ConstraintValidator的成员变量minValue访问到当前限制类型Min的value属性了\r\n       return value >= minValue;\r\n    }\r\n \r\n}\r\n```\r\n继续来说一下ConstraintValidator泛型的第二个类型，我们已经知道它的第二个类型是对应的isValid的方法的第一个参数，从我给的参数名称value来看也可以知道isValid方法的第一个参数正是对应的当前需要校验的数据的值，而它的类型也正是对应的我们需要校验的数据的数据类型。这两者的数据类型必须保持一致，否则Spring会提示找不到对应数据类型的ConstraintValidator。建立了自己的限制类型及其对应的ConstraintValidator后，其用法跟标准的JSR-303限制类型是一样的。以下就是使用了上述自己定义的JSR-303限制类型——Money限制和Min限制的一个实体类：\r\n```\r\npublic class User {\r\n   \r\n    private int age;\r\n   \r\n    private Double salary;\r\n \r\n    @Min(value=8, message=\"年龄不能小于8岁\")\r\n    public int getAge() {\r\n       return age;\r\n    }\r\n \r\n    public void setAge(int age) {\r\n       this.age = age;\r\n    }\r\n \r\n    @Money(message=\"标准的金额形式为xxx.xx\")\r\n    public Double getSalary() {\r\n       return salary;\r\n    }\r\n \r\n    public void setSalary(Double salary) {\r\n       this.salary = salary;\r\n    }\r\n   \r\n}\r\n```\r\n\r\n\r\n  [1]: http://haohaoxuexi.iteye.com/blog/1812584','SpringMVC',1,0,0,0,1,'2016-10-05 11:44:58','2016-10-05 11:45:00',1,NULL,NULL),
	(7,'Java学习记录--ThreadLocal使用案例',1,'java学习记录–ThreadLocal使用案例标签（空格分隔）： java最近整理公司项目,发现不少写的比较糟糕的地方,比如下面这个:public class DateUtil { private final static SimpleDateFormat sdfyhm = new SimpleDateFormat( \"yyyyMMdd\"); public sy...','<h1 id=\"title\">java学习记录–ThreadLocal使用案例</h1>\r\n\r\n<p>标签（空格分隔）： java</p>\r\n\r\n<hr>\r\n\r\n<p>本文借由并发环境下使用线程不安全的SimpleDateFormat优化案例,帮助大家理解ThreadLocal.</p>\r\n\r\n<hr>\r\n\r\n<p>最近整理公司项目,发现不少写的比较糟糕的地方,比如下面这个:</p>\r\n\r\n<pre class=\"prettyprint hljs-dark\"><code class=\" hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">DateUtil</span> {</span>\r\n\r\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">static</span> SimpleDateFormat sdfyhm = <span class=\"hljs-keyword\">new</span> SimpleDateFormat(\r\n            <span class=\"hljs-string\">\"yyyyMMdd\"</span>);\r\n\r\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">synchronized</span> <span class=\"hljs-keyword\">static</span> Date <span class=\"hljs-title\">parseymdhms</span>(String source) {\r\n        <span class=\"hljs-keyword\">try</span> {\r\n            <span class=\"hljs-keyword\">return</span> sdfyhm.parse(source);\r\n        } <span class=\"hljs-keyword\">catch</span> (ParseException e) {\r\n            e.printStackTrace();\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> Date();\r\n        }\r\n    }\r\n\r\n}</code></pre>\r\n\r\n<p>首先分析下: <br>\r\n该处的函数parseymdhms()使用了synchronized修饰,意味着该操作是线程不安全的,所以需要同步,线程不安全也只能是SimpleDateFormat的parse()方法,查看下源码,在SimpleDateFormat里面有一个局部变量</p>\r\n\r\n<pre class=\"prettyprint hljs-dark\"><code class=\" hljs r\">protected Calendar calendar;\r\n\r\nDate parse() {\r\n\r\n    calendar.clear();\r\n\r\n  <span class=\"hljs-keyword\">...</span> // 执行一些操作, 设置 calendar 的日期什么的\r\n\r\n  calendar.getTime(); // 获取calendar的时间\r\n\r\n}</code></pre>\r\n\r\n<p>该clear()操作会造成线程不安全.</p>\r\n\r\n<hr>\r\n\r\n<h3 id=\"title-1\">改进方法</h3>\r\n\r\n<p>线程不安全是源于多线程使用了共享变量造成,所以这里使用ThreadLocal<simpledateformat>来给每个线程单独创建副本变量,先给出代码,再分析这样的解决问题的原因.</simpledateformat></p>\r\n\r\n<pre class=\"prettyprint hljs-dark\"><code class=\" hljs java\"><span class=\"hljs-javadoc\">/**\r\n * 日期工具类(使用了ThreadLocal获取SimpleDateFormat,其他方法可以直接拷贝common-lang)\r\n *<span class=\"hljs-javadoctag\"> @author</span> Niu Li\r\n *<span class=\"hljs-javadoctag\"> @date</span> 2016/11/19\r\n */</span>\r\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">DateUtil</span> {</span>\r\n\r\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> Map&lt;String,ThreadLocal&lt;SimpleDateFormat&gt;&gt; sdfMap = <span class=\"hljs-keyword\">new</span> HashMap&lt;String, ThreadLocal&lt;SimpleDateFormat&gt;&gt;();\r\n\r\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> Logger logger = LoggerFactory.getLogger(DateUtil.class);\r\n\r\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">static</span> String MDHMSS = <span class=\"hljs-string\">\"MMddHHmmssSSS\"</span>;\r\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">static</span> String YMDHMS = <span class=\"hljs-string\">\"yyyyMMddHHmmss\"</span>;\r\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">static</span> String YMDHMS_ = <span class=\"hljs-string\">\"yyyy-MM-dd HH:mm:ss\"</span>;\r\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">static</span> String YMD = <span class=\"hljs-string\">\"yyyyMMdd\"</span>;\r\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">static</span> String YMD_ = <span class=\"hljs-string\">\"yyyy-MM-dd\"</span>;\r\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">static</span> String HMS = <span class=\"hljs-string\">\"HHmmss\"</span>;\r\n\r\n    <span class=\"hljs-javadoc\">/**\r\n     * 根据map中的key得到对应线程的sdf实例\r\n     *<span class=\"hljs-javadoctag\"> @param</span> pattern map中的key\r\n     *<span class=\"hljs-javadoctag\"> @return</span> 该实例\r\n     */</span>\r\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> SimpleDateFormat <span class=\"hljs-title\">getSdf</span>(<span class=\"hljs-keyword\">final</span> String pattern){\r\n        ThreadLocal&lt;SimpleDateFormat&gt; sdfThread = sdfMap.get(pattern);\r\n        <span class=\"hljs-keyword\">if</span> (sdfThread == <span class=\"hljs-keyword\">null</span>){\r\n            <span class=\"hljs-comment\">//双重检验,防止sdfMap被多次put进去值,和双重锁单例原因是一样的</span>\r\n            <span class=\"hljs-keyword\">synchronized</span> (DateUtil.class){\r\n                sdfThread = sdfMap.get(pattern);\r\n                <span class=\"hljs-keyword\">if</span> (sdfThread == <span class=\"hljs-keyword\">null</span>){\r\n                    logger.debug(<span class=\"hljs-string\">\"put new sdf of pattern \"</span> + pattern + <span class=\"hljs-string\">\" to map\"</span>);\r\n                    sdfThread = <span class=\"hljs-keyword\">new</span> ThreadLocal&lt;SimpleDateFormat&gt;(){\r\n                        <span class=\"hljs-annotation\">@Override</span>\r\n                        <span class=\"hljs-keyword\">protected</span> SimpleDateFormat <span class=\"hljs-title\">initialValue</span>() {\r\n                            logger.debug(<span class=\"hljs-string\">\"thread: \"</span> + Thread.currentThread() + <span class=\"hljs-string\">\" init pattern: \"</span> + pattern);\r\n                            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> SimpleDateFormat(pattern);\r\n                        }\r\n                    };\r\n                    sdfMap.put(pattern,sdfThread);\r\n                }\r\n            }\r\n        }\r\n        <span class=\"hljs-keyword\">return</span> sdfThread.get();\r\n    }\r\n\r\n    <span class=\"hljs-javadoc\">/**\r\n     * 按照指定pattern解析日期\r\n     *<span class=\"hljs-javadoctag\"> @param</span> date 要解析的date\r\n     *<span class=\"hljs-javadoctag\"> @param</span> pattern 指定格式\r\n     *<span class=\"hljs-javadoctag\"> @return</span> 解析后date实例\r\n     */</span>\r\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> Date <span class=\"hljs-title\">parseDate</span>(String date,String pattern){\r\n        <span class=\"hljs-keyword\">if</span>(date == <span class=\"hljs-keyword\">null</span>) {\r\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalArgumentException(<span class=\"hljs-string\">\"The date must not be null\"</span>);\r\n        }\r\n        <span class=\"hljs-keyword\">try</span> {\r\n            <span class=\"hljs-keyword\">return</span>  getSdf(pattern).parse(date);\r\n        } <span class=\"hljs-keyword\">catch</span> (ParseException e) {\r\n            e.printStackTrace();\r\n            logger.error(<span class=\"hljs-string\">\"解析的格式不支持:\"</span>+pattern);\r\n        }\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">null</span>;\r\n    }\r\n    <span class=\"hljs-javadoc\">/**\r\n     * 按照指定pattern格式化日期\r\n     *<span class=\"hljs-javadoctag\"> @param</span> date 要格式化的date\r\n     *<span class=\"hljs-javadoctag\"> @param</span> pattern 指定格式\r\n     *<span class=\"hljs-javadoctag\"> @return</span> 解析后格式\r\n     */</span>\r\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> String <span class=\"hljs-title\">formatDate</span>(Date date,String pattern){\r\n        <span class=\"hljs-keyword\">if</span> (date == <span class=\"hljs-keyword\">null</span>){\r\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalArgumentException(<span class=\"hljs-string\">\"The date must not be null\"</span>);\r\n        }<span class=\"hljs-keyword\">else</span> {\r\n            <span class=\"hljs-keyword\">return</span> getSdf(pattern).format(date);\r\n        }\r\n    }\r\n}</code></pre>\r\n\r\n<h3 id=\"title-2\">测试</h3>\r\n\r\n<p>在主线程中执行一个,另外两个在子线程执行,使用的都是同一个pattern</p>\r\n\r\n<pre class=\"prettyprint hljs-dark\"><code class=\" hljs coffeescript\">    public static <span class=\"hljs-reserved\">void</span> main(String[] args) {\r\n        DateUtil.formatDate(<span class=\"hljs-keyword\">new</span> Date(),MDHMSS);\r\n        <span class=\"hljs-keyword\">new</span> Thread<span class=\"hljs-function\"><span class=\"hljs-params\">(()-&gt;{\r\n            DateUtil.formatDate(<span class=\"hljs-keyword\">new</span> Date(),MDHMSS);\r\n        })</span>.<span class=\"hljs-title\">start</span><span class=\"hljs-params\">()</span>;\r\n        <span class=\"hljs-title\">new</span> <span class=\"hljs-title\">Thread</span><span class=\"hljs-params\">(()-&gt;{\r\n            DateUtil.formatDate(<span class=\"hljs-keyword\">new</span> Date(),MDHMSS);\r\n        })</span>.<span class=\"hljs-title\">start</span><span class=\"hljs-params\">()</span>;\r\n    }</span></code></pre>\r\n\r\n<p>日志分析</p>\r\n\r\n<pre class=\"prettyprint hljs-dark\"><code class=\" hljs lasso\">put <span class=\"hljs-literal\">new</span> sdf of pattern MMddHHmmssSSS <span class=\"hljs-keyword\">to</span> <span class=\"hljs-built_in\">map</span>\r\n<span class=\"hljs-keyword\">thread</span>: <span class=\"hljs-keyword\">Thread</span><span class=\"hljs-preprocessor\">[</span>main,<span class=\"hljs-number\">5</span>,main<span class=\"hljs-preprocessor\">]</span><span class=\"hljs-markup\"> init pattern: MMddHHmmssSSS\r\nthread: Thread</span><span class=\"hljs-preprocessor\">[</span><span class=\"hljs-keyword\">Thread</span><span class=\"hljs-subst\">-</span><span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">5</span>,main<span class=\"hljs-preprocessor\">]</span><span class=\"hljs-markup\"> init pattern: MMddHHmmssSSS\r\nthread: Thread</span><span class=\"hljs-preprocessor\">[</span><span class=\"hljs-keyword\">Thread</span><span class=\"hljs-subst\">-</span><span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">5</span>,main<span class=\"hljs-preprocessor\">]</span><span class=\"hljs-markup\"> init pattern: MMddHHmmssSSS</span></code></pre>\r\n\r\n<h3 id=\"title-3\">分析</h3>\r\n\r\n<p>可以看出来sdfMap put进去了一次,而SimpleDateFormat被new了三次,因为代码中有三个线程.那么这是为什么呢?</p>\r\n\r\n<p>对于每一个线程Thread,其内部有一个<code>ThreadLocal.ThreadLocalMap threadLocals</code>的全局变量引用,ThreadLocal.ThreadLocalMap里面有一个保存该ThreadLocal和对应value,一图胜千言,结构图如下:</p>\r\n\r\n<p><img src=\"http://img.blog.csdn.net/20161119160421833\" alt=\"这里写图片描述\" title=\"\"></p>\r\n\r\n<p>那么对于sdfMap的话,结构图就变更了下</p>\r\n\r\n<p><img src=\"http://img.blog.csdn.net/20161119160815822\" alt=\"这里写图片描述\" title=\"\"></p>\r\n\r\n<p>那么日志为什么是这样的?分析下:</p>\r\n\r\n<h4 id=\"title-4\">1.首先第一次执行<code>DateUtil.formatDate(new Date(),MDHMSS);</code></h4>\r\n\r\n<pre class=\"prettyprint hljs-dark\"><code class=\" hljs java\"><span class=\"hljs-comment\">//第一次执行DateUtil.formatDate(new Date(),MDHMSS)分析</span>\r\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> SimpleDateFormat <span class=\"hljs-title\">getSdf</span>(<span class=\"hljs-keyword\">final</span> String pattern){\r\n        ThreadLocal&lt;SimpleDateFormat&gt; sdfThread = sdfMap.get(pattern);\r\n        <span class=\"hljs-comment\">//得到的sdfThread为null,进入if语句</span>\r\n        <span class=\"hljs-keyword\">if</span> (sdfThread == <span class=\"hljs-keyword\">null</span>){\r\n            <span class=\"hljs-keyword\">synchronized</span> (DateUtil.class){\r\n                sdfThread = sdfMap.get(pattern);\r\n                <span class=\"hljs-comment\">//sdfThread仍然为null,进入if语句</span>\r\n                <span class=\"hljs-keyword\">if</span> (sdfThread == <span class=\"hljs-keyword\">null</span>){\r\n                    <span class=\"hljs-comment\">//打印日志</span>\r\n                    logger.debug(<span class=\"hljs-string\">\"put new sdf of pattern \"</span> + pattern + <span class=\"hljs-string\">\" to map\"</span>);\r\n                    <span class=\"hljs-comment\">//创建ThreadLocal实例,并覆盖initialValue方法</span>\r\n                    sdfThread = <span class=\"hljs-keyword\">new</span> ThreadLocal&lt;SimpleDateFormat&gt;(){\r\n                        <span class=\"hljs-annotation\">@Override</span>\r\n                        <span class=\"hljs-keyword\">protected</span> SimpleDateFormat <span class=\"hljs-title\">initialValue</span>() {\r\n                            logger.debug(<span class=\"hljs-string\">\"thread: \"</span> + Thread.currentThread() + <span class=\"hljs-string\">\" init pattern: \"</span> + pattern);\r\n                            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> SimpleDateFormat(pattern);\r\n                        }\r\n                    };\r\n                    <span class=\"hljs-comment\">//设置进如sdfMap</span>\r\n                    sdfMap.put(pattern,sdfThread);\r\n                }\r\n            }\r\n        }\r\n        <span class=\"hljs-keyword\">return</span> sdfThread.get();\r\n    }</code></pre>\r\n\r\n<p>这个时候可能有人会问,这里并没有调用ThreadLocal的set方法,那么值是怎么设置进入的呢? <br>\r\n这就需要看sdfThread.get()的实现:</p>\r\n\r\n<pre class=\"prettyprint hljs-dark\"><code class=\" hljs lasso\">    <span class=\"hljs-keyword\">public</span> T get() {\r\n        <span class=\"hljs-keyword\">Thread</span> t <span class=\"hljs-subst\">=</span> <span class=\"hljs-keyword\">Thread</span><span class=\"hljs-built_in\">.</span>currentThread();\r\n        ThreadLocalMap <span class=\"hljs-built_in\">map</span> <span class=\"hljs-subst\">=</span> getMap(t);\r\n        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">map</span> <span class=\"hljs-subst\">!=</span> <span class=\"hljs-built_in\">null</span>) {\r\n            ThreadLocalMap<span class=\"hljs-built_in\">.</span>Entry e <span class=\"hljs-subst\">=</span> <span class=\"hljs-built_in\">map</span><span class=\"hljs-built_in\">.</span>getEntry(this);\r\n            <span class=\"hljs-keyword\">if</span> (e <span class=\"hljs-subst\">!=</span> <span class=\"hljs-built_in\">null</span>) {\r\n                @SuppressWarnings(<span class=\"hljs-string\">\"unchecked\"</span>)\r\n                T result <span class=\"hljs-subst\">=</span> (T)e<span class=\"hljs-built_in\">.</span>value;\r\n                <span class=\"hljs-keyword\">return</span> result;\r\n            }\r\n        }\r\n        <span class=\"hljs-keyword\">return</span> setInitialValue();\r\n    }</code></pre>\r\n\r\n<p>也就是说当值不存在的时候会调用setInitialValue()方法,该方法会调用initialValue()方法,也就是我们覆盖的方法.</p>\r\n\r\n<p>对应日志打印.</p>\r\n\r\n<pre class=\"prettyprint hljs-dark\"><code class=\" hljs lasso\">put <span class=\"hljs-literal\">new</span> sdf of pattern MMddHHmmssSSS <span class=\"hljs-keyword\">to</span> <span class=\"hljs-built_in\">map</span>\r\n<span class=\"hljs-keyword\">thread</span>: <span class=\"hljs-keyword\">Thread</span><span class=\"hljs-preprocessor\">[</span>main,<span class=\"hljs-number\">5</span>,main<span class=\"hljs-preprocessor\">]</span><span class=\"hljs-markup\"> init pattern: MMddHHmmssSSS</span></code></pre>\r\n\r\n<h4 id=\"title-5\">2.第二次在子线程执行<code>DateUtil.formatDate(new Date(),MDHMSS);</code></h4>\r\n\r\n<pre class=\"prettyprint hljs-dark\"><code class=\" hljs java\"><span class=\"hljs-comment\">//第二次在子线程执行`DateUtil.formatDate(new Date(),MDHMSS);`</span>\r\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> SimpleDateFormat <span class=\"hljs-title\">getSdf</span>(<span class=\"hljs-keyword\">final</span> String pattern){\r\n        ThreadLocal&lt;SimpleDateFormat&gt; sdfThread = sdfMap.get(pattern);\r\n        <span class=\"hljs-comment\">//这里得到的sdfThread不为null,跳过if块</span>\r\n        <span class=\"hljs-keyword\">if</span> (sdfThread == <span class=\"hljs-keyword\">null</span>){\r\n            <span class=\"hljs-keyword\">synchronized</span> (DateUtil.class){\r\n                sdfThread = sdfMap.get(pattern);\r\n                <span class=\"hljs-keyword\">if</span> (sdfThread == <span class=\"hljs-keyword\">null</span>){\r\n                    logger.debug(<span class=\"hljs-string\">\"put new sdf of pattern \"</span> + pattern + <span class=\"hljs-string\">\" to map\"</span>);\r\n                    sdfThread = <span class=\"hljs-keyword\">new</span> ThreadLocal&lt;SimpleDateFormat&gt;(){\r\n                        <span class=\"hljs-annotation\">@Override</span>\r\n                        <span class=\"hljs-keyword\">protected</span> SimpleDateFormat <span class=\"hljs-title\">initialValue</span>() {\r\n                            logger.debug(<span class=\"hljs-string\">\"thread: \"</span> + Thread.currentThread() + <span class=\"hljs-string\">\" init pattern: \"</span> + pattern);\r\n                            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> SimpleDateFormat(pattern);\r\n                        }\r\n                    };\r\n                    sdfMap.put(pattern,sdfThread);\r\n                }\r\n            }\r\n        }\r\n        <span class=\"hljs-comment\">//直接调用sdfThread.get()返回</span>\r\n        <span class=\"hljs-keyword\">return</span> sdfThread.get();\r\n    }</code></pre>\r\n\r\n<p>分析sdfThread.get()</p>\r\n\r\n<pre class=\"prettyprint hljs-dark\"><code class=\" hljs lasso\"><span class=\"hljs-comment\">//第二次在子线程执行`DateUtil.formatDate(new Date(),MDHMSS);`</span>\r\n    <span class=\"hljs-keyword\">public</span> T get() {\r\n        <span class=\"hljs-keyword\">Thread</span> t <span class=\"hljs-subst\">=</span> <span class=\"hljs-keyword\">Thread</span><span class=\"hljs-built_in\">.</span>currentThread();<span class=\"hljs-comment\">//得到当前子线程</span>\r\n        ThreadLocalMap <span class=\"hljs-built_in\">map</span> <span class=\"hljs-subst\">=</span> getMap(t);\r\n        <span class=\"hljs-comment\">//子线程中得到的map为null,跳过if块</span>\r\n        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">map</span> <span class=\"hljs-subst\">!=</span> <span class=\"hljs-built_in\">null</span>) {\r\n            ThreadLocalMap<span class=\"hljs-built_in\">.</span>Entry e <span class=\"hljs-subst\">=</span> <span class=\"hljs-built_in\">map</span><span class=\"hljs-built_in\">.</span>getEntry(this);\r\n            <span class=\"hljs-keyword\">if</span> (e <span class=\"hljs-subst\">!=</span> <span class=\"hljs-built_in\">null</span>) {\r\n                @SuppressWarnings(<span class=\"hljs-string\">\"unchecked\"</span>)\r\n                T result <span class=\"hljs-subst\">=</span> (T)e<span class=\"hljs-built_in\">.</span>value;\r\n                <span class=\"hljs-keyword\">return</span> result;\r\n            }\r\n        }\r\n        <span class=\"hljs-comment\">//直接执行初始化,也就是调用我们覆盖的initialValue()方法</span>\r\n        <span class=\"hljs-keyword\">return</span> setInitialValue();\r\n    }</code></pre>\r\n\r\n<p>对应日志:</p>\r\n\r\n<pre class=\"prettyprint hljs-dark\"><code class=\" hljs mathematica\"><span class=\"hljs-keyword\">Thread</span>[<span class=\"hljs-keyword\">Thread</span>-<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">5</span>,main] init pattern: MMddHHmmssSSS</code></pre>\r\n\r\n<p>同理第三次执行和第二次类似.直接调用sdfThread.get(),然后调用initialValue()方法,对应日志</p>\r\n\r\n<pre class=\"prettyprint hljs-dark\"><code class=\" hljs mathematica\"><span class=\"hljs-keyword\">Thread</span>[<span class=\"hljs-keyword\">Thread</span>-<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">5</span>,main] init pattern: MMddHHmmssSSS</code></pre>\r\n\r\n<hr>\r\n\r\n<h3 id=\"title-6\">总结</h3>\r\n\r\n<blockquote>\r\n  <p>在什么场景下比较适合使用ThreadLocal？stackoverflow上有人给出了还不错的回答。 <br>\r\n  When and how should I use a ThreadLocal variable? <br>\r\n  One possible (and common) use is when you have some object that is not thread-safe, but you want to avoid synchronizing access to that object (I’m looking at you, SimpleDateFormat). Instead, give each thread its own instance of the object.</p>\r\n</blockquote>\r\n\r\n<p>参考资料: <br>\r\n<a href=\"http://www.importnew.com/21479.html\">http://www.importnew.com/21479.html</a> <br>\r\n<a href=\"http://www.cnblogs.com/zemliu/archive/2013/08/29/3290585.html\">http://www.cnblogs.com/zemliu/archive/2013/08/29/3290585.html</a></p>','# java学习记录--ThreadLocal使用案例\r\n\r\n标签（空格分隔）： java\r\n\r\n---\r\n\r\n本文借由并发环境下使用线程不安全的SimpleDateFormat优化案例,帮助大家理解ThreadLocal.\r\n\r\n\r\n----------\r\n\r\n\r\n最近整理公司项目,发现不少写的比较糟糕的地方,比如下面这个:\r\n\r\n```\r\npublic class DateUtil {\r\n\r\n	private final static SimpleDateFormat sdfyhm = new SimpleDateFormat(\r\n			\"yyyyMMdd\");\r\n			\r\n	public synchronized static Date parseymdhms(String source) {\r\n	    try {\r\n		    return sdfyhm.parse(source);\r\n	    } catch (ParseException e) {\r\n		    e.printStackTrace();\r\n		    return new Date();\r\n	    }\r\n	}\r\n\r\n}\r\n```\r\n\r\n首先分析下:\r\n该处的函数parseymdhms()使用了synchronized修饰,意味着该操作是线程不安全的,所以需要同步,线程不安全也只能是SimpleDateFormat的parse()方法,查看下源码,在SimpleDateFormat里面有一个局部变量\r\n```\r\nprotected Calendar calendar;\r\n\r\nDate parse() {\r\n\r\n    calendar.clear();\r\n\r\n  ... // 执行一些操作, 设置 calendar 的日期什么的\r\n\r\n  calendar.getTime(); // 获取calendar的时间\r\n\r\n}\r\n```\r\n该clear()操作会造成线程不安全.\r\n\r\n----------\r\n\r\n###改进方法\r\n线程不安全是源于多线程使用了共享变量造成,所以这里使用ThreadLocal<SimpleDateFormat>来给每个线程单独创建副本变量,先给出代码,再分析这样的解决问题的原因.\r\n\r\n```\r\n/**\r\n * 日期工具类(使用了ThreadLocal获取SimpleDateFormat,其他方法可以直接拷贝common-lang)\r\n * @author Niu Li\r\n * @date 2016/11/19\r\n */\r\npublic class DateUtil {\r\n\r\n    private static Map<String,ThreadLocal<SimpleDateFormat>> sdfMap = new HashMap<String, ThreadLocal<SimpleDateFormat>>();\r\n\r\n    private static Logger logger = LoggerFactory.getLogger(DateUtil.class);\r\n\r\n    public final static String MDHMSS = \"MMddHHmmssSSS\";\r\n    public final static String YMDHMS = \"yyyyMMddHHmmss\";\r\n    public final static String YMDHMS_ = \"yyyy-MM-dd HH:mm:ss\";\r\n    public final static String YMD = \"yyyyMMdd\";\r\n    public final static String YMD_ = \"yyyy-MM-dd\";\r\n    public final static String HMS = \"HHmmss\";\r\n\r\n    /**\r\n     * 根据map中的key得到对应线程的sdf实例\r\n     * @param pattern map中的key\r\n     * @return 该实例\r\n     */\r\n    private static SimpleDateFormat getSdf(final String pattern){\r\n        ThreadLocal<SimpleDateFormat> sdfThread = sdfMap.get(pattern);\r\n        if (sdfThread == null){\r\n            //双重检验,防止sdfMap被多次put进去值,和双重锁单例原因是一样的\r\n            synchronized (DateUtil.class){\r\n                sdfThread = sdfMap.get(pattern);\r\n                if (sdfThread == null){\r\n                    logger.debug(\"put new sdf of pattern \" + pattern + \" to map\");\r\n                    sdfThread = new ThreadLocal<SimpleDateFormat>(){\r\n                        @Override\r\n                        protected SimpleDateFormat initialValue() {\r\n                            logger.debug(\"thread: \" + Thread.currentThread() + \" init pattern: \" + pattern);\r\n                            return new SimpleDateFormat(pattern);\r\n                        }\r\n                    };\r\n                    sdfMap.put(pattern,sdfThread);\r\n                }\r\n            }\r\n        }\r\n        return sdfThread.get();\r\n    }\r\n\r\n    /**\r\n     * 按照指定pattern解析日期\r\n     * @param date 要解析的date\r\n     * @param pattern 指定格式\r\n     * @return 解析后date实例\r\n     */\r\n    public static Date parseDate(String date,String pattern){\r\n        if(date == null) {\r\n            throw new IllegalArgumentException(\"The date must not be null\");\r\n        }\r\n        try {\r\n            return  getSdf(pattern).parse(date);\r\n        } catch (ParseException e) {\r\n            e.printStackTrace();\r\n            logger.error(\"解析的格式不支持:\"+pattern);\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * 按照指定pattern格式化日期\r\n     * @param date 要格式化的date\r\n     * @param pattern 指定格式\r\n     * @return 解析后格式\r\n     */\r\n    public static String formatDate(Date date,String pattern){\r\n        if (date == null){\r\n            throw new IllegalArgumentException(\"The date must not be null\");\r\n        }else {\r\n            return getSdf(pattern).format(date);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n###测试\r\n在主线程中执行一个,另外两个在子线程执行,使用的都是同一个pattern\r\n```\r\n    public static void main(String[] args) {\r\n        DateUtil.formatDate(new Date(),MDHMSS);\r\n        new Thread(()->{\r\n            DateUtil.formatDate(new Date(),MDHMSS);\r\n        }).start();\r\n        new Thread(()->{\r\n            DateUtil.formatDate(new Date(),MDHMSS);\r\n        }).start();\r\n    }\r\n```\r\n日志分析\r\n```\r\nput new sdf of pattern MMddHHmmssSSS to map\r\nthread: Thread[main,5,main] init pattern: MMddHHmmssSSS\r\nthread: Thread[Thread-0,5,main] init pattern: MMddHHmmssSSS\r\nthread: Thread[Thread-1,5,main] init pattern: MMddHHmmssSSS\r\n```\r\n\r\n###分析\r\n可以看出来sdfMap put进去了一次,而SimpleDateFormat被new了三次,因为代码中有三个线程.那么这是为什么呢?\r\n\r\n对于每一个线程Thread,其内部有一个`ThreadLocal.ThreadLocalMap threadLocals`的全局变量引用,ThreadLocal.ThreadLocalMap里面有一个保存该ThreadLocal和对应value,一图胜千言,结构图如下:\r\n\r\n![这里写图片描述](http://img.blog.csdn.net/20161119160421833)\r\n\r\n\r\n那么对于sdfMap的话,结构图就变更了下\r\n\r\n![这里写图片描述](http://img.blog.csdn.net/20161119160815822)\r\n\r\n那么日志为什么是这样的?分析下:\r\n\r\n####1.首先第一次执行`DateUtil.formatDate(new Date(),MDHMSS);`\r\n\r\n```\r\n//第一次执行DateUtil.formatDate(new Date(),MDHMSS)分析\r\n    private static SimpleDateFormat getSdf(final String pattern){\r\n        ThreadLocal<SimpleDateFormat> sdfThread = sdfMap.get(pattern);\r\n        //得到的sdfThread为null,进入if语句\r\n        if (sdfThread == null){\r\n            synchronized (DateUtil.class){\r\n                sdfThread = sdfMap.get(pattern);\r\n                //sdfThread仍然为null,进入if语句\r\n                if (sdfThread == null){\r\n                    //打印日志\r\n                    logger.debug(\"put new sdf of pattern \" + pattern + \" to map\");\r\n                    //创建ThreadLocal实例,并覆盖initialValue方法\r\n                    sdfThread = new ThreadLocal<SimpleDateFormat>(){\r\n                        @Override\r\n                        protected SimpleDateFormat initialValue() {\r\n                            logger.debug(\"thread: \" + Thread.currentThread() + \" init pattern: \" + pattern);\r\n                            return new SimpleDateFormat(pattern);\r\n                        }\r\n                    };\r\n                    //设置进如sdfMap\r\n                    sdfMap.put(pattern,sdfThread);\r\n                }\r\n            }\r\n        }\r\n        return sdfThread.get();\r\n    }\r\n```\r\n这个时候可能有人会问,这里并没有调用ThreadLocal的set方法,那么值是怎么设置进入的呢?\r\n这就需要看sdfThread.get()的实现:\r\n```\r\n    public T get() {\r\n        Thread t = Thread.currentThread();\r\n        ThreadLocalMap map = getMap(t);\r\n        if (map != null) {\r\n            ThreadLocalMap.Entry e = map.getEntry(this);\r\n            if (e != null) {\r\n                @SuppressWarnings(\"unchecked\")\r\n                T result = (T)e.value;\r\n                return result;\r\n            }\r\n        }\r\n        return setInitialValue();\r\n    }\r\n```\r\n也就是说当值不存在的时候会调用setInitialValue()方法,该方法会调用initialValue()方法,也就是我们覆盖的方法.\r\n\r\n对应日志打印.\r\n```\r\nput new sdf of pattern MMddHHmmssSSS to map\r\nthread: Thread[main,5,main] init pattern: MMddHHmmssSSS\r\n```\r\n\r\n####2.第二次在子线程执行`DateUtil.formatDate(new Date(),MDHMSS);`\r\n```\r\n//第二次在子线程执行`DateUtil.formatDate(new Date(),MDHMSS);`\r\n    private static SimpleDateFormat getSdf(final String pattern){\r\n        ThreadLocal<SimpleDateFormat> sdfThread = sdfMap.get(pattern);\r\n        //这里得到的sdfThread不为null,跳过if块\r\n        if (sdfThread == null){\r\n            synchronized (DateUtil.class){\r\n                sdfThread = sdfMap.get(pattern);\r\n                if (sdfThread == null){\r\n                    logger.debug(\"put new sdf of pattern \" + pattern + \" to map\");\r\n                    sdfThread = new ThreadLocal<SimpleDateFormat>(){\r\n                        @Override\r\n                        protected SimpleDateFormat initialValue() {\r\n                            logger.debug(\"thread: \" + Thread.currentThread() + \" init pattern: \" + pattern);\r\n                            return new SimpleDateFormat(pattern);\r\n                        }\r\n                    };\r\n                    sdfMap.put(pattern,sdfThread);\r\n                }\r\n            }\r\n        }\r\n        //直接调用sdfThread.get()返回\r\n        return sdfThread.get();\r\n    }\r\n```\r\n分析sdfThread.get()\r\n```\r\n//第二次在子线程执行`DateUtil.formatDate(new Date(),MDHMSS);`\r\n    public T get() {\r\n        Thread t = Thread.currentThread();//得到当前子线程\r\n        ThreadLocalMap map = getMap(t);\r\n        //子线程中得到的map为null,跳过if块\r\n        if (map != null) {\r\n            ThreadLocalMap.Entry e = map.getEntry(this);\r\n            if (e != null) {\r\n                @SuppressWarnings(\"unchecked\")\r\n                T result = (T)e.value;\r\n                return result;\r\n            }\r\n        }\r\n        //直接执行初始化,也就是调用我们覆盖的initialValue()方法\r\n        return setInitialValue();\r\n    }\r\n```\r\n\r\n对应日志:\r\n```\r\nThread[Thread-0,5,main] init pattern: MMddHHmmssSSS\r\n```\r\n\r\n同理第三次执行和第二次类似.直接调用sdfThread.get(),然后调用initialValue()方法,对应日志\r\n```\r\nThread[Thread-1,5,main] init pattern: MMddHHmmssSSS\r\n```\r\n\r\n\r\n----------\r\n\r\n\r\n###总结\r\n\r\n>在什么场景下比较适合使用ThreadLocal？stackoverflow上有人给出了还不错的回答。\r\nWhen and how should I use a ThreadLocal variable?\r\nOne possible (and common) use is when you have some object that is not thread-safe, but you want to avoid synchronizing access to that object (I’m looking at you, SimpleDateFormat). Instead, give each thread its own instance of the object.\r\n\r\n\r\n参考资料:\r\nhttp://www.importnew.com/21479.html\r\nhttp://www.cnblogs.com/zemliu/archive/2013/08/29/3290585.html','java,ThreadLocal',4,10,0,1,1,'2016-12-01 22:38:00','2016-12-01 22:38:02',1,NULL,NULL),
	(257428399,'java深入浅出解析异常机制',-1,'三月份啦，月初第一篇写一份异常机制的完全解析，表明这个月努力学习的决心！ \n  以下长文预警！！！\njava中的异常处理的目的在于通过使用少量的代码，使得程序有着强大的鲁棒性，并且这种异常处理机制会让...',NULL,NULL,NULL,0,0,0,0,0,'2017-03-05 13:51:06','2017-03-05 13:51:06',2,'http://blog.csdn.net/quinnnorris/article/details/57428399','QuinnNorris'),
	(259074806,'Paint基本用法',-1,'这篇只要记录Paint（画笔）一些基本用法\n\n\n\nsetARGB（设置画笔颜色和透明度）\n\n\n\npaint.setARGB(88,255,0,0);\nsetARGB(int a, int r, int...',NULL,NULL,NULL,0,0,0,0,0,'2017-03-05 13:51:06','2017-03-05 13:51:06',2,'http://blog.csdn.net/zjws23786/article/details/59074806','zjws23786'),
	(259112145,'Centos 安装 nghttp2 做 grpc 的http2 代理',-1,'1，nghttp2和nginx 名字比较像，但是是一个c的llib库。本身也可做http服务。 \n也可以做代理服务器，支持ssl。 \n之前也做过测试了 \nhttp://blog.csdn.net/fr...',NULL,NULL,NULL,0,0,0,0,0,'2017-03-05 13:51:06','2017-03-05 13:51:06',2,'http://blog.csdn.net/freewebsys/article/details/59112145','freewebsys'),
	(259113935,'Android插件化完美实现代码资源加载及原理讲解 附可运行demo',-1,'我们通过前4篇的分解，分别将插件化设计到的知识点全部梳理了一遍，如果没有看过的，本文详解讲解了动态加载插件apk的实现步骤及原理，并附可运行demo，并且demo中实现了插件可以使用自己资源的问题，由...',NULL,NULL,NULL,0,0,0,0,0,'2017-03-05 21:50:20','2017-03-05 21:50:20',2,'http://blog.csdn.net/yulong0809/article/details/59113935','yulong0809'),
	(259147132,'【Unity优化】Unity中究竟能不能使用foreach？',-1,'关于这个话题，网络上讨论的很多，我也收集了一些资料，都不是很齐全，所以自己亲自测试，这里把结果分享给大家。foreach究竟怎么了？研究过这个问题的人都应该知道，就是它会引起频繁的GC Alloc。也...',NULL,NULL,NULL,0,0,0,0,0,'2017-03-05 21:50:20','2017-03-05 21:50:20',2,'http://blog.csdn.net/andrewfan/article/details/59147132','AndrewFan'),
	(259538738,'Android WebView那些坑之上传文件',-1,'解决问题之前我们先来说说`WebView`上传文件的逻辑：当我们在Web页面上点击选择文件的控件(``)时，会回调`WebChromeClient`下的`openFileChooser()`（5.0及...',NULL,NULL,NULL,0,0,0,0,0,'2017-03-05 21:50:20','2017-03-05 21:50:20',2,'http://blog.csdn.net/baron_leizhang/article/details/59538738','baron_leizhang'),
	(259787319,' 一个想法（续二）：换个角度思考如何解决IT企业招聘难的问题！',-1,'上一篇文章：一个想法：成立草根技术联盟对开发人员进行技术定级解决企业员工招聘难问题！当时写文的思维，是从一个公益组织的角度的思考。因此，有不少关于从利出发的反方观点，的确是值的思考，任何的改革都需要平...',NULL,NULL,NULL,0,0,0,0,0,'2017-03-05 21:50:20','2017-03-05 21:50:20',2,'http://blog.csdn.net/cyq1162/article/details/59787319','cyq1162'),
	(260130381,'开启D3：是什么让程序员与设计师如此钟爱',-1,'D3是一个开源的JavaScript程序库。它对设计师来说很友好，因为它能让设计师使用SVG这种常见的图形格式进行创作。它对程序员来说也很合适，因为它是兼容Web标准的。下面让我们开启D3，聊聊这个在...',NULL,NULL,NULL,0,0,0,0,0,'2017-03-05 13:51:06','2017-03-05 13:51:06',2,'http://blog.csdn.net/broadview2006/article/details/60130381','broadview2006'),
	(260132580,'设计模式学习笔记之适配器模式',-1,'设计模式学习笔记之适配器模式',NULL,NULL,NULL,0,0,0,0,0,'2017-03-05 21:50:20','2017-03-05 21:50:20',2,'http://blog.csdn.net/zhurui_idea/article/details/60132580','u012269327'),
	(260141953,'<Android开源库> Realm For Android~ Getting Help and Models（译文）',-1,'帮助  & 模型',NULL,NULL,NULL,0,0,0,0,0,'2017-03-05 21:50:20','2017-03-05 21:50:20',2,'http://blog.csdn.net/poorkick/article/details/60141953','poorkick'),
	(260143077,'iOS 进度条、加载、安装动画 —— HERO博客',-1,'iOS 进度条、加载、安装动画简单实现。',NULL,NULL,NULL,0,0,0,0,0,'2017-03-05 13:51:06','2017-03-05 13:51:06',2,'http://blog.csdn.net/hero_wqb/article/details/60143077','hero_wqb'),
	(260151482,'Android的Handler深入解析',-1,'1、概述前面写过一篇文章《Android中的消息机制》简单分析了异步消息机制，本文将深入解读Handler的原理。2、基本概念\n单线程模型中的Message、Handler、Message Queue...',NULL,NULL,NULL,0,0,0,0,0,'2017-03-05 21:50:20','2017-03-05 21:50:20',2,'http://blog.csdn.net/ztchun/article/details/60151482','zhoutaochun'),
	(260153376,'jenkins实现项目自动部署',-1,'背景\n整体思路\n实现方式\n1 自动化部署脚本\n2 远程执行\n3 配置jenkins任务背景之前给公司搭建过一套gitlab+gerrit+jenkins的持续集成环境，由于操作起来有点繁琐，自己也没太...',NULL,NULL,NULL,0,0,0,0,0,'2017-03-05 13:51:06','2017-03-05 13:51:06',2,'http://blog.csdn.net/feiniao8651/article/details/60153376','feiniao8651'),
	(260311533,'hadoop2.5.2学习13-MR之新浪微博-DF的实现',-1,'本文接上篇hadoop2.5.2学习13-MR之新浪微博TF-IDF算法简介 \n 上篇微博实现了第一个mappreduce， 统计的词频TF和微博总数N \n本文将统计DF，即每个词条在多少个文章中出现...',NULL,NULL,NULL,0,0,0,0,0,'2017-03-05 13:51:06','2017-03-05 13:51:06',2,'http://blog.csdn.net/wuxintdrh/article/details/60311533','wuxintdrh'),
	(260312894,'令人比较失落的IT圈子-关于华为裁员 ',-1,'早在几年前就有人说过程序员在35岁以后如果不做管理就很难混了，如今由于近日的华为事件被炒得沸沸扬扬，显然让这多年前人们的猜测变成了现实，我今年也正好到了这个该“退休”的年龄，所以就想趁机悔恨一番。首先...',NULL,NULL,NULL,0,0,0,0,0,'2017-03-05 13:51:06','2017-03-05 13:51:06',2,'http://blog.csdn.net/dog250/article/details/60312894','dog250'),
	(260321123,'几种Java序列化方式的实现',-1,'0、前言\n\n本文主要对几种常见Java序列化方式进行实现。包括Java原生以流的方法进行的序列化、Json序列化、FastJson序列化、Protobuff序列化。\n\n\n1、Java原生序列化\n\nJa...',NULL,NULL,NULL,0,0,0,0,0,'2017-03-05 13:51:06','2017-03-05 13:51:06',2,'http://blog.csdn.net/pistolove/article/details/60321123','pistolove'),
	(260323541,'JVM理解',-1,'一台机器上能起多少个JVM？\n一台机器（操作系统）能启动多个JVM进程，各个JVM进程有独自的数据空间和代码空间，互不影响，并且每调用java命令之后（执行启动类的main函数），就是启动一个JVM实...',NULL,NULL,NULL,0,0,0,0,0,'2017-03-05 21:50:20','2017-03-05 21:50:20',2,'http://blog.csdn.net/u013467442/article/details/60323541','u013467442'),
	(260324988,'浅谈JVM及原理',-1,'1、什么是JVM ?\r\nJVM， 中文名是Java虚拟机， 正如它的名字， 是一个虚拟机器，来模拟通用的物理机。 JVM是一个标准，一套规范，  规定了.class文件在其内部运行的相关标准和规范。 ...',NULL,NULL,NULL,0,0,0,0,0,'2017-03-05 21:50:20','2017-03-05 21:50:20',2,'http://blog.csdn.net/weiguolong0306/article/details/60324988','weiguolong0306'),
	(260325107,'【并发编程】当我们谈论线程安全时我们在谈论什么',-1,'线程安全是一个老生长谈的话题，做开发的人人都会碰到且谈论这个话题，今天就来从内存角度上深入剖析一下什么是线程安全。\n       首先，我们知道jvm内存总体来讲分为：栈、堆、程序计数器、方法区。其中...',NULL,NULL,NULL,0,0,0,0,0,'2017-03-05 21:50:20','2017-03-05 21:50:20',2,'http://blog.csdn.net/silk_bar/article/details/60325107','silk_bar'),
	(260326262,'Android中使用Handler以及CountDownTimer实现包含倒计时的闪屏页面',-1,'上一篇博文《Android中Handler使用浅析》通过实现倒计时闪屏页面的制作引出了Handler的使用方法以及实现原理，博文末尾也提到了实现过程中的Bug，有兴趣的朋友可以点击链接回去看看。今天通...',NULL,NULL,NULL,0,0,0,0,0,'2017-03-05 21:50:20','2017-03-05 21:50:20',2,'http://blog.csdn.net/panhouye/article/details/60326262','panhouye'),
	(260332412,'ZooKeeper源码学习笔记(3)--Cluster模式下的ZooKeeper',-1,'ZooKeeper 的 Cluster 模式',NULL,NULL,NULL,0,0,0,0,0,'2017-03-05 13:51:06','2017-03-05 13:51:06',2,'http://blog.csdn.net/kifile/article/details/60332412','kifile'),
	(260332971,'微信小程序-scroll-view横向滚动和上拉加载',-1,'今天介绍微信小程序中scroll-view实现横向滚动和上拉加载的实现及需要注意的地方。 \n先看最终效果。横向滚动1.设置滚动项display：inline-block; \n2.设置滚动视图容器whi...',NULL,NULL,NULL,0,0,0,0,0,'2017-03-05 13:51:06','2017-03-05 13:51:06',2,'http://blog.csdn.net/u013778905/article/details/60332971','u013778905'),
	(260334688,'深入理解Node系列-细说Connect(上)',-1,'前言想必对于广大前后端的同学们，Node 或是用来作为网站服务器的搭建，亦或是用来作为开发脚手架的运用，或是早有套路，亦或是浅尝辄止。从现在开始博主将会不定时的对 Node 系列的产品做分析，其中夹杂...',NULL,NULL,NULL,0,0,0,0,0,'2017-03-05 21:50:20','2017-03-05 21:50:20',2,'http://blog.csdn.net/yingxiaoqiang520/article/details/60334688','yingxiaoqiang520'),
	(260344699,'Google 地图 API for Android',-1,'原文：Introduction to Google Maps API for Android \n  作者： Eunice Obugyei  \n  译者：kmyhy\n从健康类 app Runkeeper...',NULL,NULL,NULL,0,0,0,0,0,'2017-03-05 13:51:06','2017-03-05 13:51:06',2,'http://blog.csdn.net/kmyhy/article/details/60344699','kmyhy'),
	(260346089,'深度学习（五十四）图片翻译WGAN实验测试',-1,'WGAN相比于GAN的优点在于：具有更高的稳定性。在原始的WGAN中，作者通过一堆的理论，提出了WGAN，理论证明n多页，不过代码实现就两行：(1)去掉了判别网络的判别的概念，在原始的GAN中，判别网...',NULL,NULL,NULL,0,0,0,0,0,'2017-03-05 13:51:06','2017-03-05 13:51:06',2,'http://blog.csdn.net/hjimce/article/details/60346089','hjimce'),
	(260347828,'《懒人Shell脚本》之八——定期备份Mysql数据库表的实现',-1,'0.背景实际开发环境中，前端程序需要在给定时间段内，将数据更新/插入到mysql指定的库表中。随着数据量的增多，基础库表基数的增长，每更新一次都会有5s左右的卡顿。 \n改进方案一：批量更新，累计数10...',NULL,NULL,NULL,0,0,0,0,0,'2017-03-05 21:50:20','2017-03-05 21:50:20',2,'http://blog.csdn.net/laoyang360/article/details/60347828','wojiushiwo987'),
	(260349107,'AFNetworking访问https出现\"NSURLSession/NSURLConnection HTTP load failed (kCFStreamErrorDomainSSL, -9813\"',-1,'使用AFNetworking来访问http请求非常方便快捷，最简单的请求代码如下：#import \"HSTestHTTPSViewController.h\"\n#import \n\n@interface ...',NULL,NULL,NULL,0,0,0,0,0,'2017-03-05 13:51:06','2017-03-05 13:51:06',2,'http://blog.csdn.net/chenyufeng1991/article/details/60349107','CHENYUFENG1991'),
	(260358317,' 论项目管理中当面沟通的重要性',-1,'0、沟通问题的由来近段时间，团队中出现了管理方面的这样、那样的问题。团队领导不去直面问题，与当事人直接当面沟通。而是采取了“旁敲侧击”的方式，找相关人员沟通。仅从沟通效率的角度，效率非常低下；从沟通效...',NULL,NULL,NULL,0,0,0,0,0,'2017-03-05 21:50:20','2017-03-05 21:50:20',2,'http://blog.csdn.net/laoyang360/article/details/60358317','wojiushiwo987'),
	(260368049,'CSDN日报20170304——《令人比较失落的IT圈子-关于华为裁员》  ',-1,'早在几年前就有人说过程序员在35岁以后如果不做管理就很难混了，如今由于近日的华为事件被炒得沸沸扬扬，显然让这多年前人们的猜测变成了现实，我今年也正好到了这个该“退休”的年龄，所以就想趁机悔恨一番。首先...',NULL,NULL,NULL,0,0,0,0,0,'2017-03-05 13:51:06','2017-03-05 13:51:06',2,'http://blog.csdn.net/blogdevteam/article/details/60368049','blogdevteam'),
	(260465948,'几个面试常考的问题',-1,'前言\n判断一个数是否为2的幂\n不使用if while forswitchgoto等关键字实现100行代码打印出1000个helloworld\n不使用实现一个加法函数\n不使用-实现减法函数\n实现BMP算...',NULL,NULL,NULL,0,0,0,0,0,'2017-03-05 21:50:20','2017-03-05 21:50:20',2,'http://blog.csdn.net/marksinoberg/article/details/60465948','Marksinoberg'),
	(260466183,'Serverless架构的演进',-1,'Serverless架构的演进作者：chszs，未经博主允许不得转载。经许可的转载需注明作者和博客主页：http://blog.csdn.net/chszsServerless架构风格挑战了软件设计和...',NULL,NULL,NULL,0,0,0,0,0,'2017-03-05 21:50:20','2017-03-05 21:50:20',2,'http://blog.csdn.net/chszs/article/details/60466183','chszs'),
	(260466381,' grpc（4）：使用 golang 调用consul api 接口，注册user-tomcat服务',-1,'1，关于consuldubbo的注册中心是zookeeper，redis。 \nmotan的注册中心是zookeeper，consul。 \nkubernetes的注册中心是 etcd。 \n使用consu...',NULL,NULL,NULL,0,0,0,0,0,'2017-03-05 21:50:20','2017-03-05 21:50:20',2,'http://blog.csdn.net/freewebsys/article/details/60466381','freewebsys'),
	(260468818,'【Python数据挖掘课程】九.回归模型LinearRegression简单分析氧化物数据',-1,'这篇文章主要介绍三个知识点，也是我《数据挖掘与分析》课程讲课的内容。同时主要参考学生的课程提交作业内容进行讲述，包括：\n        1.回归模型及基础知识；\n        2.UCI数据集；\n ...',NULL,NULL,NULL,0,0,0,0,0,'2017-03-05 21:50:20','2017-03-05 21:50:20',2,'http://blog.csdn.net/eastmount/article/details/60468818','Eastmount'),
	(260470024,'由学习《软件设计重构》所想到的代码review（二）',-1,'我们接第一篇 由学习《软件设计重构》所想到的代码review（一） \n来继续说明在代码review中，有哪些属于“层次结构”中的坏味道。注：通过上图咱们看到了在层次结构中有九大问题点，咱们就从中找出三...',NULL,NULL,NULL,0,0,0,0,0,'2017-03-05 21:50:20','2017-03-05 21:50:20',2,'http://blog.csdn.net/u013970991/article/details/60470024','u013970991'),
	(260473425,'CSDN日报20170305——《谈谈学习方法》  ',-1,'之前很多人给我留言，说因为兴趣，选择了编程，而且自己也很努力，也在持续坚持学习，然而觉得自己没有任何进步，甚至一度怀疑自己不适合编程。还有工作了一两年的同学给我留言，说感觉自己也挺吃苦的，做的项目也挺...',NULL,NULL,NULL,0,0,0,0,0,'2017-03-05 21:50:20','2017-03-05 21:50:20',2,'http://blog.csdn.net/blogdevteam/article/details/60473425','blogdevteam');

/*!40000 ALTER TABLE `article` ENABLE KEYS */;
UNLOCK TABLES;


# Dump of table catelog
# ------------------------------------------------------------

DROP TABLE IF EXISTS `catelog`;

CREATE TABLE `catelog` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(30) DEFAULT NULL,
  `type` tinyint(4) DEFAULT '1' COMMENT '0题目分类',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

LOCK TABLES `catelog` WRITE;
/*!40000 ALTER TABLE `catelog` DISABLE KEYS */;

INSERT INTO `catelog` (`id`, `name`, `type`)
VALUES
	(1,'语言入门',0),
	(2,'数据结构',0),
	(3,'贪心算法',0),
	(4,'搜索',0),
	(5,'数学基础',0),
	(6,'图论',0),
	(7,'矩阵计算',0),
	(8,'动态规划',0);

/*!40000 ALTER TABLE `catelog` ENABLE KEYS */;
UNLOCK TABLES;


# Dump of table contest
# ------------------------------------------------------------

DROP TABLE IF EXISTS `contest`;

CREATE TABLE `contest` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `title` varchar(255) DEFAULT NULL,
  `start_time` datetime DEFAULT NULL,
  `end_time` datetime DEFAULT NULL,
  `description` text COMMENT '描述信息',
  `type` tinyint(4) DEFAULT NULL COMMENT '1校赛,2公开赛',
  `password` varchar(50) DEFAULT NULL COMMENT '所需密码',
  `create_user` varchar(30) DEFAULT NULL COMMENT '创建用户',
  `defunct` tinyint(4) DEFAULT '1' COMMENT '1有效,0无效',
  `createdate` datetime DEFAULT NULL,
  `modifydate` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

LOCK TABLES `contest` WRITE;
/*!40000 ALTER TABLE `contest` DISABLE KEYS */;

INSERT INTO `contest` (`id`, `title`, `start_time`, `end_time`, `description`, `type`, `password`, `create_user`, `defunct`, `createdate`, `modifydate`)
VALUES
	(1,'安徽理工大学第一届程序设计大赛','2017-02-18 12:13:45','2017-03-30 12:13:49','不来就吃亏哈,来了就奖励哈',1,'123456','牛李',1,'2016-11-18 12:14:20','2016-11-26 12:14:29'),
	(2,'安徽省联合程序设计大赛','2017-03-01 12:14:48','2017-03-01 12:14:53','不来就吃亏哈',2,'123456','牛李',1,'2016-11-18 12:15:18','2016-11-25 12:15:20'),
	(3,'中国程序设计大赛','2016-11-01 12:15:35','2016-11-10 12:15:39','来了才吃亏哈',2,NULL,'牛李',1,'2016-11-03 12:16:02','2016-11-05 12:16:06'),
	(4,'联合国程序设计大赛','2016-11-03 12:16:33','2016-11-15 12:16:35','来了就吃亏哈',2,NULL,'牛李',1,'2016-11-18 12:16:56','2016-11-17 12:16:59');

/*!40000 ALTER TABLE `contest` ENABLE KEYS */;
UNLOCK TABLES;


# Dump of table contest_problem
# ------------------------------------------------------------

DROP TABLE IF EXISTS `contest_problem`;

CREATE TABLE `contest_problem` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `problem_id` int(11) DEFAULT NULL,
  `contest_id` int(11) DEFAULT NULL,
  `title` varchar(255) DEFAULT NULL,
  `num` varchar(10) DEFAULT NULL,
  `point` int(5) DEFAULT '0',
  `accepted` int(11) DEFAULT '0',
  `solved` int(11) DEFAULT '0',
  `submit` int(11) DEFAULT '0',
  `submit_user` int(11) DEFAULT '0',
  `createdate` datetime DEFAULT NULL,
  `modifydate` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

LOCK TABLES `contest_problem` WRITE;
/*!40000 ALTER TABLE `contest_problem` DISABLE KEYS */;

INSERT INTO `contest_problem` (`id`, `problem_id`, `contest_id`, `title`, `num`, `point`, `accepted`, `solved`, `submit`, `submit_user`, `createdate`, `modifydate`)
VALUES
	(1,1020,1,'A+B problem','A',10,0,0,0,0,'2016-11-26 20:37:02','2016-11-26 20:37:04'),
	(3,1019,1,'A+C problem','B',20,0,0,0,0,'2016-11-26 21:19:16','2016-11-26 21:19:18');

/*!40000 ALTER TABLE `contest_problem` ENABLE KEYS */;
UNLOCK TABLES;


# Dump of table mail
# ------------------------------------------------------------

DROP TABLE IF EXISTS `mail`;

CREATE TABLE `mail` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '站内信主键',
  `user` int(11) DEFAULT NULL,
  `friend` int(11) DEFAULT NULL,
  `sender` int(11) DEFAULT NULL,
  `receiver` int(11) DEFAULT NULL,
  `type` tinyint(4) DEFAULT NULL,
  `content` text,
  `send_time` datetime DEFAULT NULL,
  `read_time` datetime DEFAULT NULL,
  `status` tinyint(4) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;



# Dump of table notify
# ------------------------------------------------------------

DROP TABLE IF EXISTS `notify`;

CREATE TABLE `notify` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '网站通知主键',
  `title` varchar(255) DEFAULT NULL COMMENT '标题',
  `article_id` int(11) DEFAULT NULL COMMENT '所关联文章',
  `expiredate` datetime DEFAULT NULL COMMENT '过期时间',
  `status` tinyint(4) DEFAULT NULL COMMENT '状态1正常,0待发布,2已过期',
  `createdate` datetime DEFAULT NULL COMMENT '创建日期',
  `modifydate` datetime DEFAULT NULL COMMENT '修改日期',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

LOCK TABLES `notify` WRITE;
/*!40000 ALTER TABLE `notify` DISABLE KEYS */;

INSERT INTO `notify` (`id`, `title`, `article_id`, `expiredate`, `status`, `createdate`, `modifydate`)
VALUES
	(1,'第八届蓝桥杯大赛即将开始',0,'2017-03-31 22:54:21',1,'2016-10-05 11:20:24','2016-10-05 11:20:26'),
	(2,'第九届安徽理工大学ACM校赛即将开始',0,'2017-03-31 22:54:30',1,'2016-10-05 11:20:46','2016-10-05 11:20:48'),
	(3,'第十届计算机学院程序设计大赛即将开始',0,'2017-03-31 22:54:33',1,'2016-10-05 11:21:14','2016-10-05 11:21:16');

/*!40000 ALTER TABLE `notify` ENABLE KEYS */;
UNLOCK TABLES;


# Dump of table problem
# ------------------------------------------------------------

DROP TABLE IF EXISTS `problem`;

CREATE TABLE `problem` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `title` varchar(255) DEFAULT NULL COMMENT '标题',
  `description` text COMMENT '描述',
  `input` text COMMENT '输入描述',
  `output` text COMMENT '输出描述',
  `sample_input` text COMMENT '输入样例',
  `sample_output` text COMMENT '输出样例',
  `keyword` varchar(255) DEFAULT NULL COMMENT '关键词',
  `hit` text COMMENT '提示',
  `catelog` tinyint(4) DEFAULT NULL COMMENT '所属目录',
  `stage` tinyint(4) DEFAULT NULL COMMENT '属于的阶段',
  `spj` tinyint(4) DEFAULT '0' COMMENT '是否特殊判题',
  `time_limit` int(11) DEFAULT NULL COMMENT '时间限制',
  `memory_limit` int(11) DEFAULT NULL COMMENT '内存限制',
  `difficulty` tinyint(4) DEFAULT '1' COMMENT '难度等级',
  `solved` int(11) DEFAULT '0' COMMENT '解决次数',
  `submit` int(11) DEFAULT '0' COMMENT '提交次数',
  `author_id` int(11) DEFAULT NULL COMMENT '作者id',
  `contest_id` int(11) DEFAULT '-1' COMMENT '所属竞赛id,-1则不存在',
  `createdate` datetime NOT NULL COMMENT '创建日期',
  `modifydate` datetime NOT NULL COMMENT '修改日期',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

LOCK TABLES `problem` WRITE;
/*!40000 ALTER TABLE `problem` DISABLE KEYS */;

INSERT INTO `problem` (`id`, `title`, `description`, `input`, `output`, `sample_input`, `sample_output`, `keyword`, `hit`, `catelog`, `stage`, `spj`, `time_limit`, `memory_limit`, `difficulty`, `solved`, `submit`, `author_id`, `contest_id`, `createdate`, `modifydate`)
VALUES
	(1000,'计算a+b','求整数a，b的和。','测试案例有多行，每行为a，b的值。','输出多行，对应a+b的结果。','1 2\r\n4 5\r\n6 9','3\r\n9\r\n15','基础 简单循环','简单程序即可',1,1,0,1000,320000,1,16,28,1,-1,'2016-10-18 21:54:38','2016-10-05 18:26:44'),
	(1001,'计算a+b','求整数a，b的和。','测试案例有多行，每行为a，b的值。','输出多行，对应a+b的结果。','1 2\r\n4 5\r\n6 9','3\r\n9\r\n15','基础','简单程序即可',1,1,0,1000,320000,1,0,0,1,-1,'2016-10-05 18:26:42','2016-10-05 18:26:44'),
	(1002,'计算a+b','求整数a，b的和。','测试案例有多行，每行为a，b的值。','输出多行，对应a+b的结果。','1 2\r\n4 5\r\n6 9','3\r\n9\r\n15','基础','简单程序即可',1,1,0,1000,320000,1,0,0,1,-1,'2016-10-05 18:26:42','2016-10-05 18:26:44'),
	(1003,'计算a+b','求整数a，b的和。','测试案例有多行，每行为a，b的值。','输出多行，对应a+b的结果。','1 2\r\n4 5\r\n6 9','3\r\n9\r\n15','基础','简单程序即可',1,1,0,1000,320000,1,0,0,1,-1,'2016-10-05 18:26:42','2016-10-05 18:26:44'),
	(1004,'计算a+b','求整数a，b的和。','测试案例有多行，每行为a，b的值。','输出多行，对应a+b的结果。','1 2\r\n4 5\r\n6 9','3\r\n9\r\n15','基础','简单程序即可',1,1,0,1000,320000,1,0,0,1,-1,'2016-10-05 18:26:42','2016-10-05 18:26:44'),
	(1005,'计算a+b','求整数a，b的和。','测试案例有多行，每行为a，b的值。','输出多行，对应a+b的结果。','1 2\r\n4 5\r\n6 9','3\r\n9\r\n15','基础','简单程序即可',1,1,0,1000,320000,2,0,0,1,-1,'2016-10-18 21:57:59','2016-10-05 18:26:44'),
	(1006,'计算a+b','求整数a，b的和。','测试案例有多行，每行为a，b的值。','输出多行，对应a+b的结果。','1 2\r\n4 5\r\n6 9','3\r\n9\r\n15','基础','简单程序即可',1,1,0,1000,320000,1,0,0,1,-1,'2016-10-05 18:26:42','2016-10-05 18:26:44'),
	(1007,'计算a+b','求整数a，b的和。','测试案例有多行，每行为a，b的值。','输出多行，对应a+b的结果。','1 2\r\n4 5\r\n6 9','3\r\n9\r\n15','基础','简单程序即可',1,1,0,1000,320000,1,0,0,1,-1,'2016-10-05 18:26:42','2016-10-05 18:26:44'),
	(1008,'计算a+b','求整数a，b的和。','测试案例有多行，每行为a，b的值。','输出多行，对应a+b的结果。','1 2\r\n4 5\r\n6 9','3\r\n9\r\n15','基础','简单程序即可',1,1,0,1000,320000,1,0,0,1,-1,'2016-10-05 18:26:42','2016-10-05 18:26:44'),
	(1009,'计算a+b','求整数a，b的和。','测试案例有多行，每行为a，b的值。','输出多行，对应a+b的结果。','1 2\r\n4 5\r\n6 9','3\r\n9\r\n15','基础','简单程序即可',1,1,0,1000,320000,1,0,0,1,-1,'2016-10-05 18:26:42','2016-10-05 18:26:44'),
	(1010,'计算a+b','求整数a，b的和。','测试案例有多行，每行为a，b的值。','输出多行，对应a+b的结果。','1 2\r\n4 5\r\n6 9','3\r\n9\r\n15','基础','简单程序即可',1,1,0,1000,320000,1,0,0,1,-1,'2016-10-05 18:26:42','2016-10-05 18:26:44'),
	(1011,'计算a+b','求整数a，b的和。','测试案例有多行，每行为a，b的值。','输出多行，对应a+b的结果。','1 2\r\n4 5\r\n6 9','3\r\n9\r\n15','基础','简单程序即可',1,1,0,1000,320000,1,0,0,1,-1,'2016-10-05 18:26:42','2016-10-05 18:26:44'),
	(1012,'计算a+b','求整数a，b的和。','测试案例有多行，每行为a，b的值。','输出多行，对应a+b的结果。','1 2\r\n4 5\r\n6 9','3\r\n9\r\n15','基础','简单程序即可',1,1,0,1000,320000,1,0,0,1,-1,'2016-10-05 18:26:42','2016-10-05 18:26:44'),
	(1013,'计算a+b','求整数a，b的和。','测试案例有多行，每行为a，b的值。','输出多行，对应a+b的结果。','1 2\r\n4 5\r\n6 9','3\r\n9\r\n15','基础','简单程序即可',1,1,0,1000,320000,1,0,0,1,-1,'2016-10-05 18:26:42','2016-10-05 18:26:44'),
	(1014,'计算a+b','求整数a，b的和。','测试案例有多行，每行为a，b的值。','输出多行，对应a+b的结果。','1 2\r\n4 5\r\n6 9','3\r\n9\r\n15','基础','简单程序即可',1,1,0,1000,320000,1,0,0,1,-1,'2016-10-05 18:26:42','2016-10-05 18:26:44'),
	(1015,'计算a+b','求整数a，b的和。','测试案例有多行，每行为a，b的值。','输出多行，对应a+b的结果。','1 2\r\n4 5\r\n6 9','3\r\n9\r\n15','基础','简单程序即可',1,1,0,1000,320000,1,0,0,1,-1,'2016-10-05 18:26:42','2016-10-05 18:26:44'),
	(1016,'计算a+b','求整数a，b的和。','测试案例有多行，每行为a，b的值。','输出多行，对应a+b的结果。','1 2\r\n4 5\r\n6 9','3\r\n9\r\n15','基础','简单程序即可',1,1,0,1000,320000,1,0,0,1,-1,'2016-10-05 18:26:42','2016-10-05 18:26:44'),
	(1017,'计算a+b','求整数a，b的和。','测试案例有多行，每行为a，b的值。','输出多行，对应a+b的结果。','1 2\r\n4 5\r\n6 9','3\r\n9\r\n15','基础','简单程序即可',1,1,0,1000,320000,1,0,0,1,1,'2016-10-05 18:26:42','2016-10-05 18:26:44'),
	(1018,'计算a+b','求整数a，b的和。','测试案例有多行，每行为a，b的值。','输出多行，对应a+b的结果。','1 2\r\n4 5\r\n6 9','3\r\n9\r\n15','基础','简单程序即可',1,1,0,1000,320000,1,0,0,1,1,'2016-10-05 18:26:42','2016-10-05 18:26:44'),
	(1019,'计算a+b','求整数a，b的和。','测试案例有多行，每行为a，b的值。','输出多行，对应a+b的结果。','1 2\r\n4 5\r\n6 9','3\r\n9\r\n15','基础','简单程序即可',1,1,0,1000,320000,1,0,0,1,1,'2016-10-05 18:26:42','2016-10-05 18:26:44'),
	(1020,'计算a+b','求整数a，b的和。','测试案例有多行，每行为a，b的值。','输出多行，对应a+b的结果。','1 2\r\n4 5\r\n6 9','3\r\n9\r\n15','基础','简单程序即可',1,1,0,1000,320000,1,0,0,1,1,'2016-10-05 18:26:42','2016-10-05 18:26:44');

/*!40000 ALTER TABLE `problem` ENABLE KEYS */;
UNLOCK TABLES;


# Dump of table problem_comment
# ------------------------------------------------------------

DROP TABLE IF EXISTS `problem_comment`;

CREATE TABLE `problem_comment` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '题目评论主键',
  `problem_id` int(11) DEFAULT NULL COMMENT '对应题目的id',
  `user_id` int(11) DEFAULT NULL COMMENT '留言用户id',
  `firend_id` int(11) DEFAULT NULL COMMENT '对方的id',
  `content` text COMMENT '留言内容',
  `likecount` int(5) DEFAULT '0' COMMENT '点赞数',
  `root_id` int(11) DEFAULT NULL COMMENT '该留言root节点',
  `status` tinyint(2) DEFAULT NULL COMMENT '1正常,10审核',
  `createdate` datetime DEFAULT NULL,
  `modifydate` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

LOCK TABLES `problem_comment` WRITE;
/*!40000 ALTER TABLE `problem_comment` DISABLE KEYS */;

INSERT INTO `problem_comment` (`id`, `problem_id`, `user_id`, `firend_id`, `content`, `likecount`, `root_id`, `status`, `createdate`, `modifydate`)
VALUES
	(4,1000,2,NULL,'应该这样来做,比如.....',13,NULL,1,'2016-11-14 13:45:30','2016-11-14 13:45:32'),
	(5,1000,1,NULL,'简单运行下就好了\r\n<pre><code>\r\n try {\r\n		    return sdfyhm.parse(source);\r\n	    } catch (ParseException e) {\r\n		    e.printStackTrace();\r\n		    return new Date();\r\n	    }\r\n</code></pre>',0,NULL,1,NULL,'2016-11-20 21:18:32'),
	(6,1000,1,NULL,' 你好吗,我很好',0,NULL,1,NULL,'2016-11-23 23:13:26'),
	(7,1000,1,NULL,' thks',0,NULL,1,NULL,NULL),
	(9,1000,1,NULL,' 谢谢回复',0,NULL,1,NULL,NULL),
	(12,1000,1,NULL,' 谢谢指导',0,NULL,1,'2016-11-20 17:21:06','2016-11-20 17:21:06'),
	(13,1000,1,NULL,' 送给你的评论',0,NULL,1,'2016-11-22 22:18:18','2016-11-22 22:18:18'),
	(14,1000,1,NULL,' 如果天空总是黑暗的，那就摸黑生存；\r\n如果发出声音是危险的，那就保持沉默；\r\n如果自觉无力发光，那就蜷伏于墙角。\r\n但不要习惯了黑暗就为黑暗辩护；\r\n也不要为自己的苟且而得意；\r\n不要嘲讽那些比自己更勇敢的人们。\r\n我们可以卑微如尘土，但不可扭曲如蛆虫。',1,NULL,1,'2016-11-22 22:18:50','2016-11-22 22:18:50'),
	(17,1000,1,NULL,'1231321',0,4,1,'2016-11-23 22:46:04','2016-11-23 22:46:04'),
	(19,1000,1,1,'哈哈哈哈',0,4,1,'2016-11-23 23:16:55','2016-11-23 23:16:55'),
	(20,1000,1,NULL,'哈哈哈',0,12,1,'2016-11-23 23:19:55','2016-11-23 23:19:55'),
	(21,1000,1,NULL,'说的很对',0,14,1,'2016-11-23 23:21:05','2016-11-23 23:21:05'),
	(22,1000,1,1,'哈哈哈',0,14,1,'2016-11-23 23:22:14','2016-11-23 23:22:14'),
	(23,1000,1,NULL,' 完成评论',0,NULL,1,'2016-11-23 23:27:16','2016-11-23 23:27:16');

/*!40000 ALTER TABLE `problem_comment` ENABLE KEYS */;
UNLOCK TABLES;


# Dump of table reportlog
# ------------------------------------------------------------

DROP TABLE IF EXISTS `reportlog`;

CREATE TABLE `reportlog` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `user_id` int(11) NOT NULL COMMENT '举报用户id',
  `type` tinyint(4) DEFAULT '1' COMMENT '举报类型,1题目评论,2文章,3文章评论',
  `other_id` int(11) DEFAULT NULL COMMENT '举报内容的id',
  `status` tinyint(2) DEFAULT '1' COMMENT '1举报,0撤销',
  `createdate` datetime DEFAULT NULL COMMENT '时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

LOCK TABLES `reportlog` WRITE;
/*!40000 ALTER TABLE `reportlog` DISABLE KEYS */;

INSERT INTO `reportlog` (`id`, `user_id`, `type`, `other_id`, `status`, `createdate`)
VALUES
	(1,1,1,2,1,'2016-11-19 23:13:53'),
	(2,1,1,1,0,'2016-11-19 23:13:56'),
	(3,1,1,4,1,'2016-11-19 23:14:17'),
	(4,1,1,14,1,'2016-11-22 22:24:00');

/*!40000 ALTER TABLE `reportlog` ENABLE KEYS */;
UNLOCK TABLES;


# Dump of table solution
# ------------------------------------------------------------

DROP TABLE IF EXISTS `solution`;

CREATE TABLE `solution` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `problem_id` int(11) NOT NULL COMMENT '题目',
  `problem_title` varchar(255) NOT NULL DEFAULT '' COMMENT '题目标题冗余',
  `user_id` int(11) NOT NULL COMMENT '提交用户id',
  `memory` int(11) DEFAULT NULL COMMENT '内存占用',
  `time` int(11) DEFAULT NULL COMMENT '耗时',
  `code_length` float DEFAULT NULL COMMENT '代码长度',
  `language` varchar(10) DEFAULT NULL COMMENT '语言',
  `contest_id` int(11) DEFAULT NULL COMMENT '属于竞赛',
  `testcase` int(11) DEFAULT NULL COMMENT '通过测试数据数',
  `verdict` tinyint(4) DEFAULT '0' COMMENT '状态',
  `createdate` datetime NOT NULL COMMENT '创建时间',
  `modifydate` datetime NOT NULL COMMENT '修改时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

LOCK TABLES `solution` WRITE;
/*!40000 ALTER TABLE `solution` DISABLE KEYS */;

INSERT INTO `solution` (`id`, `problem_id`, `problem_title`, `user_id`, `memory`, `time`, `code_length`, `language`, `contest_id`, `testcase`, `verdict`, `createdate`, `modifydate`)
VALUES
	(1,1000,'A+B problem',1,200000,200,1,'Java',-1,5,3,'2017-03-18 19:23:39','2017-03-18 19:23:42'),
	(2,1000,'计算a+b',1,NULL,NULL,0,'Java',-1,NULL,1,'2017-03-18 21:19:44','2017-03-18 21:19:44'),
	(3,1000,'计算a+b',1,NULL,NULL,0,'Java',-1,NULL,1,'2017-03-18 21:21:33','2017-03-18 21:21:33'),
	(4,1000,'计算a+b',1,NULL,NULL,0,'Java',-1,NULL,1,'2017-03-18 21:24:45','2017-03-18 21:24:45'),
	(5,1000,'计算a+b',1,NULL,NULL,0,'Java',-1,NULL,1,'2017-03-18 21:25:33','2017-03-18 21:25:33'),
	(6,1000,'计算a+b',1,NULL,NULL,0,'Java',-1,NULL,1,'2017-03-18 21:26:21','2017-03-18 21:26:21'),
	(7,1000,'计算a+b',1,0,0,0,'Java',-1,NULL,97,'2017-03-18 21:27:55','2017-03-18 21:28:14'),
	(8,1000,'计算a+b',1,26933,94,0,'Java',-1,NULL,0,'2017-03-18 21:30:59','2017-03-18 21:31:00'),
	(9,1000,'计算a+b',1,66,8,0,'C',-1,NULL,0,'2017-03-18 21:33:56','2017-03-18 21:34:04'),
	(10,1000,'计算a+b',1,0,4,0,'C++',-1,NULL,0,'2017-03-18 21:37:45','2017-03-18 21:37:47'),
	(11,1000,'计算a+b',1,0,3,0.14,'C++',-1,NULL,0,'2017-03-18 21:51:06','2017-03-18 21:51:55'),
	(12,1000,'计算a+b',1,0,0,0.12,'Java',-1,0,97,'2017-03-18 22:21:06','2017-03-18 22:21:08'),
	(13,1000,'计算a+b',1,0,2,0.12,'C',-1,0,0,'2017-03-18 22:32:41','2017-03-18 22:32:43');

/*!40000 ALTER TABLE `solution` ENABLE KEYS */;
UNLOCK TABLES;


# Dump of table solution_source
# ------------------------------------------------------------

DROP TABLE IF EXISTS `solution_source`;

CREATE TABLE `solution_source` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `solution_id` int(11) DEFAULT NULL,
  `source` text,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

LOCK TABLES `solution_source` WRITE;
/*!40000 ALTER TABLE `solution_source` DISABLE KEYS */;

INSERT INTO `solution_source` (`id`, `solution_id`, `source`)
VALUES
	(1,2,'12345'),
	(2,3,'123132'),
	(3,4,'2131'),
	(4,5,'1231'),
	(5,6,'12313'),
	(6,7,'1212312'),
	(7,8,'import java.io.*;\r\nimport java.util.*;\r\npublic class Main\r\n{\r\n            public static void main(String args[]) throws Exception\r\n            {\r\n                    Scanner cin=new Scanner(System.in);\r\n                    int a=cin.nextInt(),b=cin.nextInt();\r\n                    System.out.println(a+b);\r\n            }\r\n}'),
	(8,9,'#include <stdio.h>\r\n\r\nint main()\r\n{\r\n    int a,b;\r\n    scanf(\"%d %d\",&a, &b);\r\n    printf(\"%d\\n\",a+b);\r\n    return 0;\r\n}'),
	(9,10,'#include <iostream>\r\n\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n    int a,b;\r\n    cin >> a >> b;\r\n    cout << a+b << endl;\r\n    return 0;\r\n}'),
	(10,11,'#include <iostream>\r\n\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n    int a,b;\r\n    cin >> a >> b;\r\n    cout << a+b << endl;\r\n    return 0;\r\n}\r\n'),
	(11,12,'#include <stdio.h>\r\n\r\nint main()\r\n{\r\n    int a,b;\r\n    scanf(\"%d %d\",&a, &b);\r\n    printf(\"%d\\n\",a+b);\r\n    return 0;\r\n}'),
	(12,13,'#include <stdio.h>\r\n\r\nint main()\r\n{\r\n    int a,b;\r\n    scanf(\"%d %d\",&a, &b);\r\n    printf(\"%d\\n\",a+b);\r\n    return 0;\r\n}');

/*!40000 ALTER TABLE `solution_source` ENABLE KEYS */;
UNLOCK TABLES;


# Dump of table tags
# ------------------------------------------------------------

DROP TABLE IF EXISTS `tags`;

CREATE TABLE `tags` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `tag` varchar(30) DEFAULT NULL,
  `count` int(11) DEFAULT '0',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

LOCK TABLES `tags` WRITE;
/*!40000 ALTER TABLE `tags` DISABLE KEYS */;

INSERT INTO `tags` (`id`, `tag`, `count`)
VALUES
	(1,'Spring',0),
	(2,'ACM',0),
	(3,'Mybatis',0),
	(4,'Java',2),
	(5,'OJ',0),
	(6,'Github',1),
	(7,'SQL',0),
	(8,'Thymeleaf',0),
	(9,'SpringMVC',0),
	(10,'AJAX',0),
	(11,'Angular',0),
	(12,'react',0),
	(13,'jQuery',0),
	(14,'vue',0),
	(15,'sqlyog',0),
	(16,'IDEA',0),
	(17,'Intellij',0),
	(18,'eclipse',0),
	(19,'fragment',0);

/*!40000 ALTER TABLE `tags` ENABLE KEYS */;
UNLOCK TABLES;


# Dump of table user
# ------------------------------------------------------------

DROP TABLE IF EXISTS `user`;

CREATE TABLE `user` (
  `id` bigint(11) unsigned NOT NULL AUTO_INCREMENT COMMENT '主键,自增',
  `avatar` varchar(255) DEFAULT NULL COMMENT '用户头像链接',
  `username` varchar(50) NOT NULL COMMENT '用户名,不可修改,弃用,邮箱+密码登录',
  `password` varchar(256) NOT NULL COMMENT '密码,sha256存储',
  `nickname` varchar(30) DEFAULT NULL COMMENT '昵称,可修改',
  `qq_openid` varchar(255) DEFAULT NULL COMMENT 'QQ登录的授权id',
  `email` varchar(100) NOT NULL COMMENT '邮箱',
  `school` varchar(100) DEFAULT NULL COMMENT '学校',
  `student_no` varchar(30) DEFAULT NULL COMMENT '学号',
  `motto` varchar(255) DEFAULT '这家伙很懒,什么都没留下' COMMENT '座右铭',
  `honor` varchar(255) DEFAULT NULL COMMENT '所得荣誉',
  `point` int(11) NOT NULL DEFAULT '0' COMMENT '积分',
  `language` tinyint(4) DEFAULT '2' COMMENT '常用语言1 C 2 C++ 3 Java',
  `submit` int(11) DEFAULT '0' COMMENT '提交次数',
  `solved` int(11) DEFAULT '0' COMMENT '解决题目数',
  `is_show` tinyint(4) unsigned DEFAULT '0' COMMENT '首页展示 1是 0否',
  `blog` varchar(255) DEFAULT NULL COMMENT '博客链接',
  `ip` varchar(100) DEFAULT NULL COMMENT '登录IP',
  `is_lock` tinyint(4) unsigned NOT NULL DEFAULT '0' COMMENT '是否锁定 1是 0否',
  `loginfail` int(1) unsigned DEFAULT '0' COMMENT '登录失败次数',
  `lockdate` datetime DEFAULT NULL COMMENT '锁定日期',
  `createdate` datetime NOT NULL COMMENT '创建日期',
  `modifydate` datetime NOT NULL COMMENT '修改日期',
  `is_defunct` tinyint(4) unsigned DEFAULT '0' COMMENT '是否冻结,0正常,1冻结,2待验证',
  `is_opensource` tinyint(4) unsigned DEFAULT '1' COMMENT '是否开放代码,1是 0否',
  `is_email` tinyint(4) DEFAULT '1' COMMENT '是否接收邮件,1是 0否',
  PRIMARY KEY (`id`),
  UNIQUE KEY `email` (`email`),
  UNIQUE KEY `username` (`username`),
  UNIQUE KEY `qq_openid` (`qq_openid`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

LOCK TABLES `user` WRITE;
/*!40000 ALTER TABLE `user` DISABLE KEYS */;

INSERT INTO `user` (`id`, `avatar`, `username`, `password`, `nickname`, `qq_openid`, `email`, `school`, `student_no`, `motto`, `honor`, `point`, `language`, `submit`, `solved`, `is_show`, `blog`, `ip`, `is_lock`, `loginfail`, `lockdate`, `createdate`, `modifydate`, `is_defunct`, `is_opensource`, `is_email`)
VALUES
	(1,'https://avatars1.githubusercontent.com/u/13889883?v=3&s=460','nl101531','bcb15f821479b4d5772bd0ca866c00ad5f926e3580720659cc80d39c9d09802a','牛李',NULL,'1015315668@qq.com','安徽理工大学',NULL,'吃得苦中苦,方为人上人','XX大赛中获得二等奖',0,2,17,4,1,'http://blog.csdn.net/u012706811','127.0.0.1',0,0,NULL,'2016-10-19 18:18:44','2017-03-18 22:31:50',0,1,1),
	(2,'http://mrdear.cn:8080/static/images/default-avatar.jpg','nl123','123456','张三',NULL,'1015315669@qq.com','安徽理工大学','111111','吃得苦中苦,方为人上人','XX大赛中获得二等奖',0,2,0,0,1,'http://blog.csdn.net/u012706811','192.168.0.1',0,0,NULL,'2016-09-17 14:23:51','2016-09-12 09:51:12',0,1,1),
	(3,'http://mrdear.cn:8080/static/images/default-avatar.jpg','nl124','123456','李四',NULL,'1015315661@qq.com','安徽理工大学','111111','吃得苦中苦,方为人上人','XX大赛中获得二等奖',0,2,0,0,1,'http://blog.csdn.net/u012706811','192.168.0.1',0,0,NULL,'2016-09-17 14:23:54','2016-09-12 09:51:12',0,1,1),
	(4,'http://mrdear.cn:8080/static/images/default-avatar.jpg','nl125','123456','王二',NULL,'1015315662@qq.com','安徽理工大学','111111','吃得苦中苦,方为人上人','XX大赛中获得二等奖',0,2,0,0,1,'http://blog.csdn.net/u012706811','192.168.0.1',0,0,NULL,'2016-09-17 14:23:59','2016-09-12 09:51:12',0,1,1),
	(5,'http://mrdear.cn:8080/static/images/default-avatar.jpg','nl126','123456','码子',NULL,'1015315663@qq.com','安徽理工大学','111111','吃得苦中苦,方为人上人','XX大赛中获得二等奖',0,2,0,0,1,'http://blog.csdn.net/u012706811','192.168.0.1',0,0,NULL,'2016-09-17 14:24:02','2016-09-12 09:51:12',0,1,1),
	(6,'http://mrdear.cn:8080/static/images/default-avatar.jpg','nl127','123456','红红',NULL,'1015315664@qq.com','安徽理工大学','111111','吃得苦中苦,方为人上人','XX大赛中获得二等奖',0,2,0,0,1,'http://blog.csdn.net/u012706811','192.168.0.1',0,0,NULL,'2016-09-17 14:24:06','2016-09-12 09:51:12',0,1,1),
	(7,'http://mrdear.cn:8080/static/images/default-avatar.jpg','nl128','123456','绿绿',NULL,'1015315665@qq.com','安徽理工大学','111111','吃得苦中苦,方为人上人','XX大赛中获得二等奖',0,2,0,0,1,'http://blog.csdn.net/u012706811','192.168.0.1',0,0,NULL,'2016-09-17 14:24:12','2016-09-12 09:51:12',0,1,1),
	(14,NULL,'1192683842@qq.com','bcb15f821479b4d5772bd0ca866c00ad5f926e3580720659cc80d39c9d09802a','笑笑',NULL,'1192683842@qq.com',NULL,NULL,'这家伙很懒,什么都没留下',NULL,0,2,0,0,0,NULL,'169.254.113.232',0,0,NULL,'2017-01-25 23:15:15','2017-01-25 23:15:15',2,1,1),
	(15,NULL,'1015315668111111@qq.com','bcb15f821479b4d5772bd0ca866c00ad5f926e3580720659cc80d39c9d09802a','哈哈',NULL,'1015315668111111@qq.com',NULL,NULL,'这家伙很懒,什么都没留下',NULL,0,2,0,0,0,NULL,'169.254.113.232',0,0,NULL,'2017-01-26 12:51:23','2017-01-26 12:51:23',2,1,1);

/*!40000 ALTER TABLE `user` ENABLE KEYS */;
UNLOCK TABLES;


# Dump of table votelog
# ------------------------------------------------------------

DROP TABLE IF EXISTS `votelog`;

CREATE TABLE `votelog` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `user_id` bigint(11) NOT NULL COMMENT '用户id',
  `type` tinyint(4) NOT NULL DEFAULT '1' COMMENT '类型,1:题目留言点赞,2文章点赞,3文章留言点赞',
  `other_id` bigint(11) NOT NULL COMMENT '点赞对象的id',
  `status` tinyint(2) DEFAULT '1' COMMENT '0取消,1有效',
  `createtime` datetime DEFAULT NULL COMMENT '创建时间',
  `modifytime` datetime DEFAULT NULL COMMENT '修改时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

LOCK TABLES `votelog` WRITE;
/*!40000 ALTER TABLE `votelog` DISABLE KEYS */;

INSERT INTO `votelog` (`id`, `user_id`, `type`, `other_id`, `status`, `createtime`, `modifytime`)
VALUES
	(8,1,1,4,1,'2016-11-19 23:05:39',NULL),
	(9,1,1,2,-1,'2016-11-19 23:08:13',NULL),
	(10,1,1,14,1,'2016-11-22 22:18:52',NULL),
	(11,1,2,1,1,'2016-11-28 14:54:27',NULL),
	(12,1,2,2,1,'2016-11-29 23:03:06',NULL),
	(13,1,2,3,1,'2016-11-29 23:08:42',NULL),
	(24,1,2,7,1,'2017-01-30 15:51:15',NULL);

/*!40000 ALTER TABLE `votelog` ENABLE KEYS */;
UNLOCK TABLES;



/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;
/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
